module VotingT where

import DA.Assert
import DA.Set as S
import DA.List as L
import Daml.Script


-- template Vote
--   with
--     issuer : Party
--     proposal : Text
--     voters : Party
--   where
--     signatory issuer, voters

data Proposal = Proposal
    with
        proposer : Party
        text : Text
    deriving (Eq, Show)

type BallotKey = (Party, Proposal)

template Ballot
    with
        issuer : Party
        proposal : Proposal
        voters : Party
        voted : Party
        votes : [Bool]
    where
        signatory issuer, voted
        observer voters

        key (issuer, proposal) : BallotKey
        maintainer key._1

        choice Add : ()
            with voter : Party
            controller issuer
            do
                create this with voters = S.insert voter voters
                pure ()

        -- choice Decide : ContractId Decision
        --     controller issuer
        --     do
        --         assertMsg "All voters must vote" $ size voters == length votes
        --         let yays = length $ L.filter (\v -> v) votes
        --         let nays = length $ L.filter (\v -> not v) votes
        --         assertMsg "Cannot decide on tie" $ yays /= nays
        --         let accept = yays > nays
        --         create Decision with ..

        choice Vote : ()
            with
                voter : Party
                accept : Bool
            controller voter
            do
                assertMsg "Voter not added" $ member voter voters
                assertMsg "Voter already voted" $ not $ member voter voted
                create this with voted = S.insert voter voted; votes = accept :: votes
                pure ()

        -- choice Accept : ContractId Vote
        --     controller voters
        --     do create Vote with ..

-- template AcceptDecline
--     with
--         issuer : Party
--         voters : Party
--         response : Text
--     where
--         signatory issuer
--         observer voters

--         choice Yes : ContractId AcceptDecline
--             controller voters
--             do create AcceptDecline with ..
        


-- test = script do
--   bank <- allocateParty "Moderator"
--   alice <- allocateParty "Alice"
--   steve <- allocateParty "Steve"
-- --   voters <- allocateParty [steve, alice]
--   proposalId <- submit bank do
--     createCmd Ballot with
--          issuer = bank
--          proposal = "Trump"
--          voters = alice

--   proposalId <- submit alice do
--     createCmd AcceptDecline with
--          issuer = alice
--          response = "Yes"
--          voters = bank

-- --   proposalId <- submit steve do
-- --     createCmd AcceptDecline with
-- --          issuer = steve
-- --          response = "Yes"
-- --          voters = bank



--   coinId <- submit bank do
--     exerciseCmd proposalId Yes
--   Some coin <- queryContractId bank coinId
--   assertEq coin.issuer alice
--   assertEq coin.voters bankvalidVote : Script ()
validVote = script do
  g <- allocateParty "Government"
  a <- allocateParty "A"
  b <- allocateParty "B"
  c <- allocateParty "C"
  p <- allocateParty "Proposer"
  let proposal = Proposal with proposer = p; text = "My Proposal"
  let ballotKey = (g, proposal)
  submit g do createCmd Ballot with issuer = g; proposal; voters = S.empty; voted = S.empty; votes = []
  submit g do exerciseByKeyCmd @Ballot ballotKey Add with voter = a
  submit g do exerciseByKeyCmd @Ballot ballotKey Add with voter = b
  submit g do exerciseByKeyCmd @Ballot ballotKey Add with voter = c
  submit a do exerciseByKeyCmd @Ballot ballotKey Vote with voter = a; accept = False
  submit b do exerciseByKeyCmd @Ballot ballotKey Vote with voter = b; accept = False
  submit c do exerciseByKeyCmd @Ballot ballotKey Vote with voter = c; accept = True
  -- decision <- submit g do exerciseByKeyCmd @Ballot ballotKey Decide
  return ()
