{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WsState = exports.assert = exports.UserRightHelper = void 0; // Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar types_1 = require(\"@daml/types\");\n\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\n\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nvar events_1 = require(\"events\");\n\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\n\nvar lodash_1 = __importStar(require(\"lodash\"));\n\nvar partyInfoDecoder = jtv.object({\n  identifier: jtv.string(),\n  displayName: jtv.optional(jtv.string()),\n  isLocal: jtv.boolean()\n});\nvar userDecoder = jtv.object({\n  userId: jtv.string(),\n  primaryParty: jtv.optional(jtv.string())\n});\n\nvar UserRightHelper =\n/** @class */\nfunction () {\n  function UserRightHelper() {}\n\n  UserRightHelper.canActAs = function (party) {\n    return {\n      type: \"CanActAs\",\n      party: party\n    };\n  };\n\n  UserRightHelper.canReadAs = function (party) {\n    return {\n      type: \"CanReadAs\",\n      party: party\n    };\n  };\n\n  UserRightHelper.participantAdmin = {\n    type: \"ParticipantAdmin\"\n  };\n  return UserRightHelper;\n}();\n\nexports.UserRightHelper = UserRightHelper;\nvar userRightDecoder = jtv.oneOf(jtv.object({\n  type: jtv.constant(\"CanActAs\"),\n  party: jtv.string()\n}), jtv.object({\n  type: jtv.constant(\"CanReadAs\"),\n  party: jtv.string()\n}), jtv.object({\n  type: jtv.constant(\"ParticipantAdmin\")\n}));\n\nvar decode = function (decoder, data) {\n  return jtv.Result.withException(decoder.run(data));\n};\n/**\n * Decoder for a [[CreateEvent]].\n */\n\n\nvar decodeCreateEvent = function (template) {\n  return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: (0, types_1.ContractId)(template).decoder,\n    signatories: (0, types_1.List)(types_1.Party).decoder,\n    observers: (0, types_1.List)(types_1.Party).decoder,\n    agreementText: types_1.Text.decoder,\n    key: template.keyDecoder,\n    payload: template.decoder\n  });\n};\n/**\n * Decoder for a [[CreateEvent]] of unknown contract template.\n */\n\n\nvar decodeCreateEventUnknown = jtv.valueAt([\"templateId\"], jtv.string()).andThen(function (templateId) {\n  return decodeCreateEvent((0, types_1.lookupTemplate)(templateId));\n});\n/**\n * Decoder for an [[ArchiveEvent]].\n */\n\nvar decodeArchiveEvent = function (template) {\n  return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: (0, types_1.ContractId)(template).decoder\n  });\n};\n/**\n * Decoder for an [[ArchiveEvent]] of unknown contract template.\n */\n\n\nvar decodeArchiveEventUnknown = jtv.valueAt([\"templateId\"], jtv.string()).andThen(function (templateId) {\n  return decodeArchiveEvent((0, types_1.lookupTemplate)(templateId));\n});\n/**\n * Decoder for an [[Event]].\n */\n\nvar decodeEvent = function (template) {\n  return jtv.oneOf(jtv.object({\n    created: decodeCreateEvent(template),\n    matchedQueries: jtv.array(jtv.number())\n  }), jtv.object({\n    created: decodeCreateEvent(template)\n  }), jtv.object({\n    archived: decodeArchiveEvent(template)\n  }));\n};\n/**\n * Decoder for an [[Event]] with unknown contract template.\n */\n\n\nvar decodeEventUnknown = jtv.oneOf(jtv.object({\n  created: decodeCreateEventUnknown,\n  matchedQueries: jtv.array(jtv.number())\n}), jtv.object({\n  created: decodeCreateEventUnknown\n}), jtv.object({\n  archived: decodeArchiveEventUnknown\n}));\n/**\n * @internal\n */\n\nfunction decodeArchiveResponse(template, archiveMethod, // eslint-disable-next-line @typescript-eslint/ban-types\narchiveCommand) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, _b, events;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , archiveCommand()];\n\n        case 1:\n          _a = _c.sent(), _b = _a[0], events = _a[1];\n\n          if (events.length === 1 && \"archived\" in events[0] && events[0].archived.templateId === template.templateId) {\n            return [2\n            /*return*/\n            , events[0].archived];\n          } else {\n            throw Error(\"Ledger.\".concat(archiveMethod, \" is expected to cause one archive event for template \").concat(template.templateId, \"       but caused \").concat(JSON.stringify(events), \".\"));\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/**\n * @internal\n */\n\n\nfunction isRecordWith(field, x) {\n  return typeof x === \"object\" && x !== null && field in x;\n}\n/**\n *\n * @internal\n */\n\n\nfunction isCreateWithMatchedQueries(event) {\n  return isRecordWith(\"created\", event);\n}\n/** @internal\n * exported for testing only\n */\n\n\nfunction assert(b, m) {\n  if (!b) {\n    throw m;\n  }\n}\n\nexports.assert = assert; // TODO(MH): Support comparison queries.\n\n/** @internal\n *\n * Official documentation (docs/source/json-api/search-query-language.rst)\n * currently explicitly forbids the use of lists, textmaps and genmaps in\n * queries. As long as that restriction stays, there is no need for any kind of\n * encoding here.\n */\n\nfunction encodeQuery(_template, query) {\n  return query;\n}\n/**\n * @internal\n */\n\n\nvar decodeLedgerResponse = jtv.object({\n  status: jtv.number(),\n  result: jtv.unknownJson(),\n  warnings: jtv.optional(jtv.unknownJson())\n});\n/**\n * @internal\n */\n\nvar decodeLedgerError = jtv.object({\n  status: jtv.number(),\n  errors: jtv.array(jtv.string()),\n  warnings: jtv.optional(jtv.unknownJson())\n});\n\nvar StreamEventEmitter =\n/** @class */\nfunction (_super) {\n  __extends(StreamEventEmitter, _super);\n\n  function StreamEventEmitter(_a) {\n    var beforeClosing = _a.beforeClosing;\n\n    var _this = _super.call(this) || this;\n\n    _this.beforeClosing = beforeClosing;\n    return _this;\n  }\n\n  StreamEventEmitter.prototype.close = function () {\n    this.beforeClosing();\n    this.emit(\"close\", {\n      code: 4000,\n      reason: \"called .close()\"\n    });\n    this.removeAllListeners();\n  };\n\n  return StreamEventEmitter;\n}(events_1.EventEmitter);\n\nvar NoOffsetReceivedYet = Symbol(\"NoOffsetReceivedYet\");\nvar NullOffsetReceived = Symbol(\"NullOffsetReceived\");\n\nfunction append(map, key, value) {\n  var _a;\n\n  if (map.has(key)) {\n    (_a = map.get(key)) === null || _a === void 0 ? void 0 : _a.push(value);\n  } else {\n    map.set(key, [value]);\n  }\n}\n/**\n * @deprecated All usages of this function should be replaced by just\n *             iterating over the iterator. For this to happen, the TS\n *             compiler requires the --downlevelIteration flag, which\n *             however does not play nicely with Jest when running the\n *             tests.\n *\n * TODO Moving the compilation target to ES6 probably would solve this, investigate.\n */\n\n\nfunction materialize(iterator) {\n  return Array.from(iterator);\n}\n\nvar WsState;\n\n(function (WsState) {\n  WsState[WsState[\"Connecting\"] = 0] = \"Connecting\";\n  WsState[WsState[\"Open\"] = 1] = \"Open\";\n  WsState[WsState[\"Closing\"] = 2] = \"Closing\";\n  WsState[WsState[\"Closed\"] = 3] = \"Closed\";\n})(WsState = exports.WsState || (exports.WsState = {}));\n/**\n * @internal\n *\n * A special handler for stream requests to the /v1/stream/query endpoint.\n * The query endpoint supports providing offsets on a per-query basis.\n * This class leverages this feature by multiplexing virtual streaming requests to a single web socket.\n */\n\n\nvar QueryStreamsManager =\n/** @class */\nfunction () {\n  function QueryStreamsManager(_a) {\n    var token = _a.token,\n        wsBaseUrl = _a.wsBaseUrl,\n        reconnectThreshold = _a.reconnectThreshold; // Mutable state BEGIN\n    // Ongoing streaming queries that will be the downstream consumers of web socket messages\n\n    this.queries = new Set(); // Lookup tables used to route events to the relevant consumers:\n    //  - consumers for create events can be looked up based on their match index\n    //    - store the offset by which a match indexes needs to be shifted before the event is passed to the consumer\n    //  - archive events can be lookup up by template identifier\n    //    - this causes the consumer to observe what is known as \"phantom archives\", which are known and documented\n\n    this.matchIndexLookupTable = [];\n    this.templateIdsLookupTable = {}; // Accumulates each query in a flattened form to be sent as a single request to the JSON API\n\n    this.request = []; // to track changes on web socket queries\n\n    this.wsQueriesChange = false;\n    this.protocols = [\"jwt.token.\" + token, \"daml.ws.auth\"];\n    this.url = wsBaseUrl + QueryStreamsManager.ENDPOINT;\n    this.reconnectThresholdMs = reconnectThreshold;\n  }\n\n  QueryStreamsManager.toRequest = function (query) {\n    var request = query.queries.length == 0 ? [{\n      templateIds: [query.template.templateId]\n    }] : query.queries.map(function (q) {\n      return {\n        templateIds: [query.template.templateId],\n        query: encodeQuery(query.template, q)\n      };\n    });\n\n    if (typeof query.offset === \"string\") {\n      for (var _i = 0, request_1 = request; _i < request_1.length; _i++) {\n        var r = request_1[_i];\n        r.offset = query.offset;\n      }\n    }\n\n    return request;\n  };\n\n  QueryStreamsManager.prototype.resetAllState = function () {\n    // close ws if defined\n    if (this.ws !== undefined) {\n      this.ws.close();\n    }\n\n    this.queries.clear();\n    this.matchIndexLookupTable = [];\n    this.templateIdsLookupTable = {};\n    this.request = [];\n    this.ws = undefined;\n    this.wsLiveSince = undefined;\n    this.wsQueriesChange = false;\n  };\n\n  QueryStreamsManager.prototype.handleQueriesChange = function () {\n    //eslint-disable-next-line @typescript-eslint/no-this-alias\n    var manager = this; // stable self-reference for callbacks\n\n    if (manager.queries.size > 0) {\n      if (manager.ws !== undefined) {\n        //set the queries change flag to true, this should eventually get reset once the ws is closed.\n        manager.wsQueriesChange = true;\n        manager.wsLiveSince = undefined;\n        manager.ws.close();\n        manager.ws = undefined;\n      }\n\n      var ws = new isomorphic_ws_1.default(manager.url, manager.protocols);\n\n      var onWsMessage_1 = function (ws) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return function (_a) {\n          var data = _a.data;\n\n          if (ws.readyState === WsState.Open) {\n            var json = JSON.parse(data.toString());\n\n            if (isRecordWith(\"events\", json)) {\n              var events = jtv.Result.withException(jtv.array(decodeEventUnknown).run(json.events));\n              var multiplexer = new Map();\n\n              for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n                var event_1 = events_2[_i];\n\n                if (isCreateWithMatchedQueries(event_1)) {\n                  var consumersToMatchedQueries = new Map();\n\n                  for (var _b = 0, _c = event_1.matchedQueries; _b < _c.length; _b++) {\n                    var matchIndex = _c[_b];\n                    var _d = manager.matchIndexLookupTable[matchIndex],\n                        consumer = _d[0],\n                        matchIndexOffset = _d[1];\n                    append(consumersToMatchedQueries, consumer, matchIndexOffset);\n                  }\n\n                  for (var _e = 0, _f = materialize(consumersToMatchedQueries.entries()); _e < _f.length; _e++) {\n                    var _g = _f[_e],\n                        consumer = _g[0],\n                        matchedQueries = _g[1]; // Create a new copy of the event for each consumer to freely mangle the matched queries and avoid sharing mutable state\n\n                    append(multiplexer, consumer, __assign(__assign({}, event_1), {\n                      matchedQueries: matchedQueries\n                    }));\n                  }\n                } else if (\"archived\" in event_1) {\n                  var consumers = manager.templateIdsLookupTable[event_1.archived.templateId];\n\n                  for (var _h = 0, _j = materialize(consumers.values()); _h < _j.length; _h++) {\n                    var consumer = _j[_h]; // Create a new copy of the event for each consumer to avoid sharing mutable state\n\n                    append(multiplexer, consumer, __assign({}, event_1));\n                  }\n                } else {\n                  console.error(\"\".concat(event_1, \" unknown event type received, expected created with matchedQueries or archived\"), json);\n                }\n              }\n\n              for (var _k = 0, _m = materialize(multiplexer.entries()); _k < _m.length; _k++) {\n                var _o = _m[_k],\n                    consumer = _o[0],\n                    events_4 = _o[1];\n\n                for (var _p = 0, events_3 = events_4; _p < events_3.length; _p++) {\n                  var event_2 = events_3[_p];\n\n                  if (isCreateWithMatchedQueries(event_2)) {\n                    consumer.state.set(event_2.created.contractId, event_2.created);\n                  } else if (\"archived\" in event_2) {\n                    consumer.state.delete(event_2.archived.contractId);\n                  }\n                }\n\n                consumer.stream.emit(\"change\", Array.from(consumer.state.values()), events_4);\n              }\n\n              if (isRecordWith(\"offset\", json)) {\n                var offset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n\n                if (manager.wsLiveSince === undefined) {\n                  //on receiving the first offset event we consider the web socket to be live.\n                  manager.wsLiveSince = Date.now();\n                }\n\n                for (var _q = 0, _r = materialize(manager.queries.values()); _q < _r.length; _q++) {\n                  var consumer = _r[_q];\n\n                  if (!(typeof consumer.offset === \"string\")) {\n                    // Rebuilding the state array from scratch to make sure mutable state is not shared between the 'change' and 'live' event\n                    consumer.stream.emit(\"live\", Array.from(consumer.state.values()));\n                  }\n\n                  if (typeof offset === \"string\") {\n                    consumer.offset = offset;\n                  } else {\n                    consumer.offset = NullOffsetReceived;\n                  }\n                }\n              }\n            } else if (isRecordWith(\"warnings\", json)) {\n              for (var _s = 0, _u = materialize(manager.queries.values()); _s < _u.length; _s++) {\n                var query = _u[_s];\n                console.warn(\"\".concat(query.caller, \" warnings\"), json);\n              }\n            } else if (isRecordWith(\"errors\", json)) {\n              for (var _v = 0, _w = materialize(manager.queries.values()); _v < _w.length; _v++) {\n                var query = _w[_v];\n                console.warn(\"\".concat(query.caller, \" errors\"), json);\n              }\n            } else {\n              for (var _x = 0, _y = materialize(manager.queries.values()); _x < _y.length; _x++) {\n                var query = _y[_x];\n                console.error(\"\".concat(query.caller, \" unknown message\"), json);\n              }\n            }\n          }\n        };\n      };\n\n      var onWsOpen_1 = function () {\n        var _a; // only make a new websocket request if we have registered queries\n\n\n        if (manager.queries.size > 0) {\n          var newRequests = [];\n          var newMatchIndexLookupTable = [];\n\n          for (var _i = 0, _b = materialize(manager.queries.values()); _i < _b.length; _i++) {\n            var query = _b[_i];\n            var request = QueryStreamsManager.toRequest(query); // Add entries to the lookup table for create events\n\n            var matchIndexOffset = newMatchIndexLookupTable.length;\n            var matchIndexLookupTableEntries = new Array(request.length).fill([query, matchIndexOffset]);\n            newMatchIndexLookupTable = newMatchIndexLookupTable.concat(matchIndexLookupTableEntries); // Add entries to the lookup table for archive events\n\n            for (var _c = 0, request_2 = request; _c < request_2.length; _c++) {\n              var templateIds = request_2[_c].templateIds;\n\n              for (var _d = 0, templateIds_1 = templateIds; _d < templateIds_1.length; _d++) {\n                var templateId = templateIds_1[_d];\n                manager.templateIdsLookupTable[templateId] = manager.templateIdsLookupTable[templateId] || new Set();\n                manager.templateIdsLookupTable[templateId].add(query);\n              }\n            } //since we go through all queries on the manager, we should be safely able to rebuild the whole request\n\n\n            newRequests = newRequests.concat(request);\n          }\n\n          manager.request = newRequests;\n          manager.matchIndexLookupTable = newMatchIndexLookupTable;\n          (_a = manager.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(Array.from(manager.request.values())));\n        }\n      };\n\n      var onWsClose_1 = function () {\n        //if not a web socket queries change then we need to initiate reconnect logic.\n        if (!manager.wsQueriesChange) {\n          // The web socket has been closed due to an error\n          // If the conditions are met, attempt to reconnect and/or inform downstream consumers\n          var now = Date.now();\n\n          if (manager.wsLiveSince !== undefined && now - manager.wsLiveSince >= manager.reconnectThresholdMs) {\n            console.log(\"Reconnecting ws, previously liveSince: \".concat(manager.wsLiveSince, \" and reconnectThresholdMs: \").concat(manager.reconnectThresholdMs));\n            manager.wsLiveSince = undefined;\n            var ws_1 = new isomorphic_ws_1.default(manager.url, manager.protocols);\n            ws_1.addEventListener(\"open\", onWsOpen_1);\n            ws_1.addEventListener(\"message\", onWsMessage_1(ws_1));\n            ws_1.addEventListener(\"close\", onWsClose_1);\n            manager.ws = ws_1;\n          } else {\n            // ws has closed too quickly / never managed to connect: we give up\n            for (var _i = 0, _a = materialize(manager.queries.values()); _i < _a.length; _i++) {\n              var consumer = _a[_i];\n              consumer.stream.emit(\"close\", {\n                code: 4001,\n                reason: \"ws connection failed\"\n              });\n              consumer.stream.removeAllListeners();\n            }\n\n            manager.resetAllState();\n          }\n        } else {\n          //this was triggered due to queries change , reset the flag\n          manager.wsQueriesChange = false;\n        }\n      }; // Purposefully ignoring 'error' events; they are always followed by a 'close' event, which needs to be handled anyway\n\n\n      ws.addEventListener(\"open\", onWsOpen_1);\n      ws.addEventListener(\"message\", onWsMessage_1(ws));\n      ws.addEventListener(\"close\", onWsClose_1); //eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      manager.ws = ws;\n    }\n  };\n\n  QueryStreamsManager.prototype.streamSubmit = function (template, queries, caller) {\n    //eslint-disable-next-line @typescript-eslint/no-this-alias\n    var manager = this;\n    var query = {\n      template: template,\n      queries: queries,\n      stream: new StreamEventEmitter({\n        beforeClosing: function () {\n          manager.queries.delete(query); // if no more queries then just let it go\n\n          if (manager.queries.size > 0) {\n            manager.handleQueriesChange();\n          }\n        }\n      }),\n      state: new Map(),\n      offset: NoOffsetReceivedYet,\n      caller: caller\n    };\n    manager.queries.add(query);\n    manager.handleQueriesChange(); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var on = function (type, listener) {\n      var _a, _b;\n\n      if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open || ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n        query.stream.on(type, listener);\n      } else {\n        console.error(\"Trying to add a listener to a closed stream.\");\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var off = function (type, listener) {\n      var _a, _b;\n\n      if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open || ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n        query.stream.off(type, listener);\n      } else {\n        console.error(\"Trying to remove a listener from a closed stream.\");\n      }\n    };\n\n    var close = function () {\n      query.stream.close();\n    };\n\n    return {\n      on: on,\n      off: off,\n      close: close\n    };\n  };\n\n  QueryStreamsManager.ENDPOINT = \"v1/stream/query\";\n  return QueryStreamsManager;\n}();\n/**\n * An object of type `Ledger` represents a handle to a Daml ledger.\n */\n\n\nvar Ledger =\n/** @class */\nfunction () {\n  /**\n   * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.\n   */\n  function Ledger(_a) {\n    var token = _a.token,\n        httpBaseUrl = _a.httpBaseUrl,\n        wsBaseUrl = _a.wsBaseUrl,\n        _b = _a.reconnectThreshold,\n        reconnectThreshold = _b === void 0 ? 30000 : _b,\n        _c = _a.multiplexQueryStreams,\n        multiplexQueryStreams = _c === void 0 ? false : _c;\n\n    if (!httpBaseUrl) {\n      httpBaseUrl = \"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/\");\n    }\n\n    if (!(httpBaseUrl.startsWith(\"http://\") || httpBaseUrl.startsWith(\"https://\"))) {\n      throw Error(\"Ledger: httpBaseUrl must start with 'http://' or 'https://'. (\".concat(httpBaseUrl, \")\"));\n    }\n\n    if (!httpBaseUrl.endsWith(\"/\")) {\n      throw Error(\"Ledger: httpBaseUrl must end with '/'. (\".concat(httpBaseUrl, \")\"));\n    }\n\n    if (!wsBaseUrl) {\n      wsBaseUrl = \"ws\" + httpBaseUrl.slice(4);\n    }\n\n    if (!(wsBaseUrl.startsWith(\"ws://\") || wsBaseUrl.startsWith(\"wss://\"))) {\n      throw Error(\"Ledger: wsBaseUrl must start with 'ws://' or 'wss://'. (\".concat(wsBaseUrl, \")\"));\n    }\n\n    if (!wsBaseUrl.endsWith(\"/\")) {\n      throw Error(\"Ledger: wsBaseUrl must end with '/'. (\".concat(wsBaseUrl, \")\"));\n    }\n\n    this.token = token;\n    this.httpBaseUrl = httpBaseUrl;\n    this.wsBaseUrl = wsBaseUrl;\n    this.reconnectThreshold = reconnectThreshold;\n    this.multiplexQueryStreams = multiplexQueryStreams;\n    this.queryStreamsManager = new QueryStreamsManager({\n      token: token,\n      wsBaseUrl: wsBaseUrl,\n      reconnectThreshold: reconnectThreshold\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  Ledger.prototype.auth = function () {\n    return {\n      Authorization: \"Bearer \" + this.token\n    };\n  };\n  /**\n   * @internal\n   */\n\n\n  Ledger.prototype.throwOnError = function (r) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!r.ok) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , r.json()];\n\n          case 1:\n            json = _a.sent();\n            console.log(json);\n            throw decode(decodeLedgerError, json);\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @internal\n   *\n   * Internal function to submit a command to the JSON API.\n   */\n\n\n  Ledger.prototype.submit = function (endpoint, payload, method) {\n    if (method === void 0) {\n      method = \"post\";\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse, json, ledgerResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , (0, cross_fetch_1.default)(this.httpBaseUrl + endpoint, {\n              body: JSON.stringify(payload),\n              headers: __assign(__assign({}, this.auth()), {\n                \"Content-type\": \"application/json\"\n              }),\n              method: method\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , httpResponse.json()];\n\n          case 3:\n            json = _a.sent();\n            ledgerResponse = jtv.Result.withException(decodeLedgerResponse.run(json));\n\n            if (ledgerResponse.warnings) {\n              console.warn(ledgerResponse.warnings);\n            }\n\n            return [2\n            /*return*/\n            , ledgerResponse.result];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve contracts for a given template.\n   *\n   * When no `query` argument is given, all contracts visible to the submitting party are returned.\n   * When a `query` argument is given, only those contracts matching the query are returned. See\n   * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n   * language.\n   *\n   * @param template The contract template of the contracts to be matched against.\n   * @param query The contract query for the contracts to be matched against.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.query = function (template, query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = {\n              templateIds: [template.templateId],\n              query: encodeQuery(template, query)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/query\", payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.array(decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a contract identified by its contract ID.\n   *\n   * @param template The template of the contract to be fetched.\n   * @param contractId The contract id of the contract to be fetched.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.fetch = function (template, contractId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = {\n              templateId: template.templateId,\n              contractId: (0, types_1.ContractId)(template).encode(contractId)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/fetch\", payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a contract identified by its contract key.\n   *\n   * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of\n   * its contract id.\n   *\n   * @param template The template of the contract to be fetched.\n   * @param key The contract key of the contract to be fetched.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.fetchByKey = function (template, key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (key === undefined) {\n              throw Error(\"Cannot lookup by key on template \".concat(template.templateId, \" because it does not define a key.\"));\n            }\n\n            payload = {\n              templateId: template.templateId,\n              key: template.keyEncode(key)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/fetch\", payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Create a contract for a given template.\n   *\n   * @param template The template of the contract to be created.\n   * @param payload The template arguments for the contract to be created.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.create = function (template, payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var command, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            command = {\n              templateId: template.templateId,\n              payload: template.encode(payload)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/create\", command)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(decodeCreateEvent(template).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Exercise a choice on a contract identified by its contract ID.\n   *\n   * @param choice The choice to exercise.\n   * @param contractId The contract id of the contract to exercise.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   *\n   * @returns The return value of the choice together with a list of\n   * [[event]]'s that were created as a result of exercising the choice.\n   */\n\n\n  Ledger.prototype.exercise = function (choice, contractId, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            payload = {\n              templateId: choice.template().templateId,\n              contractId: (0, types_1.ContractId)(choice.template()).encode(contractId),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/exercise\", payload)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Exercse a choice on a newly-created contract, in a single transaction.\n   *\n   * @param choice The choice to exercise.\n   * @param payload The template arguments for the newly-created contract.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   *\n   * @returns The return value of the choice together with a list of\n   * [[event]]'s that includes the creation event for the created contract as\n   * well as all the events that were created as a result of exercising the\n   * choice, including the archive event for the created contract if the choice\n   * is consuming (or otherwise archives it as part of its execution).\n   *\n   */\n\n\n  Ledger.prototype.createAndExercise = function (choice, payload, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var command, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            command = {\n              templateId: choice.template().templateId,\n              payload: choice.template().encode(payload),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/create-and-exercise\", command)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Exercise a choice on a contract identified by its contract key.\n   *\n   * Same as [[exercise]], but the contract is identified by its contract key instead of its\n   * contract id.\n   *\n   * @param choice The choice to exercise.\n   * @param key The contract key of the contract to exercise.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   * @typeparam K The type of the contract key.\n   *\n   * @returns The return value of the choice together with a list of [[event]]'s that where created\n   * as a result of exercising the choice.\n   */\n\n\n  Ledger.prototype.exerciseByKey = function (choice, key, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (key === undefined) {\n              throw Error(\"Cannot exercise by key on template \".concat(choice.template().templateId, \" because it does not define a key.\"));\n            }\n\n            payload = {\n              templateId: choice.template().templateId,\n              key: choice.template().keyEncode(key),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit(\"v1/exercise\", payload)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Archive a contract identified by its contract ID.\n   *\n   * @param template The template of the contract to archive.\n   * @param contractId The contract id of the contract to archive.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.archive = function (template, contractId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , decodeArchiveResponse(template, \"archive\", function () {\n          return _this.exercise(template.Archive, contractId, {});\n        })];\n      });\n    });\n  };\n  /**\n   * Archive a contract identified by its contract key.\n   * Same as [[archive]], but the contract to be archived is identified by its contract key.\n   *\n   * @param template The template of the contract to be archived.\n   * @param key The contract key of the contract to be archived.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.archiveByKey = function (template, key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , decodeArchiveResponse(template, \"archiveByKey\", function () {\n          return _this.exerciseByKey(template.Archive, key, {});\n        })];\n      });\n    });\n  };\n  /**\n   * @internal\n   *\n   * Internal command to submit a request to a streaming endpoint of the\n   * JSON API. Returns a stream consisting of accumulated state together with\n   * the events that produced the latest state change. The `change` function\n   * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,\n   * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we\n   * must have the structural equalities\n   * ```\n   * change(s, []) == s\n   * change(s, x.concat(y)) == change(change(s, x), y)\n   * ```\n   * Also, `change` must never change its arguments.\n   */\n\n\n  Ledger.prototype.streamSubmit = function (callerName, template, endpoint, request, reconnectRequest, init, change) {\n    var _this = this;\n\n    var protocols = [\"jwt.token.\" + this.token, \"daml.ws.auth\"];\n    var ws = new isomorphic_ws_1.default(this.wsBaseUrl + endpoint, protocols);\n    var isLiveSince = undefined;\n    var lastOffset = undefined;\n    var state = init;\n    var isReconnecting = false;\n    var streamClosed = false;\n    var emitter = new events_1.EventEmitter();\n\n    var onWsOpen = function () {\n      if (isReconnecting) {\n        // the JSON API server can't handle null offsets, even though it sends them out under\n        // special conditions when there are no transactions yet. Not sending the `offset` message\n        // will start the stream from the very beginning of the transaction log.\n        if (lastOffset !== null) ws.send(JSON.stringify({\n          offset: lastOffset\n        }));\n        ws.send(JSON.stringify(reconnectRequest()));\n      } else {\n        ws.send(JSON.stringify(request));\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var onWsMessage = function (event) {\n      var json = JSON.parse(event.data.toString());\n\n      if (isRecordWith(\"events\", json)) {\n        var events = jtv.Result.withException(jtv.array(decodeEvent(template)).run(json.events));\n\n        if (events.length > 0) {\n          state = change(state, events);\n          emitter.emit(\"change\", state, events);\n        }\n\n        if (isRecordWith(\"offset\", json)) {\n          lastOffset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n\n          if (isLiveSince === undefined) {\n            isLiveSince = Date.now();\n            emitter.emit(\"live\", state);\n          }\n        }\n      } else if (isRecordWith(\"warnings\", json)) {\n        console.warn(\"\".concat(callerName, \" warnings\"), json);\n      } else if (isRecordWith(\"errors\", json)) {\n        console.error(\"\".concat(callerName, \" errors\"), json);\n      } else {\n        console.error(\"\".concat(callerName, \" unknown message\"), json);\n      }\n    };\n\n    var closeStream = function (status) {\n      streamClosed = true;\n      emitter.emit(\"close\", status);\n      emitter.removeAllListeners();\n    };\n\n    var onWsClose = function () {\n      if (streamClosed === false) {\n        var now = new Date().getTime(); // we want to try and keep the stream open, so we try to reconnect\n        // the underlying ws\n\n        if (lastOffset !== undefined && isLiveSince !== undefined && now - isLiveSince >= _this.reconnectThreshold) {\n          isLiveSince = undefined;\n          isReconnecting = true;\n          ws = new isomorphic_ws_1.default(_this.wsBaseUrl + endpoint, protocols);\n          ws.addEventListener(\"open\", onWsOpen);\n          ws.addEventListener(\"message\", onWsMessage);\n          ws.addEventListener(\"close\", onWsClose);\n        } else {\n          // ws has closed too quickly / never managed to connect: we give up\n          closeStream({\n            code: 4001,\n            reason: \"ws connection failed\"\n          });\n        }\n      } // no else: if the stream is closed we don't need to keep a ws\n\n    };\n\n    ws.addEventListener(\"open\", onWsOpen);\n    ws.addEventListener(\"message\", onWsMessage); // NOTE(MH): We ignore the 'error' event since it is always followed by a\n    // 'close' event, which we need to handle anyway.\n\n    ws.addEventListener(\"close\", onWsClose); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var on = function (type, listener) {\n      if (streamClosed === false) {\n        void emitter.on(type, listener);\n      } else {\n        console.error(\"Trying to add a listener to a closed stream.\");\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var off = function (type, listener) {\n      if (streamClosed === false) {\n        void emitter.off(type, listener);\n      } else {\n        console.error(\"Trying to remove a listener from a closed stream.\");\n      }\n    };\n\n    var close = function () {\n      // Note: ws.close will trigger the onClose handlers of the WebSocket\n      // (here onWsClose), but they execute as a separate event after the\n      // current event in the JS event loop, i.e. in particular after the call\n      // to closeStream and thus, in this case, the onWsClose handler will see\n      // streamClosed as true.\n      ws.close();\n      closeStream({\n        code: 4000,\n        reason: \"called .close()\"\n      });\n    };\n\n    return {\n      on: on,\n      off: off,\n      close: close\n    };\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and query.\n   *\n   * The accumulated state is the current set of active contracts matching the query. When no\n   * `query` argument is given, all events visible to the submitting party are returned. When a\n   * `query` argument is given, only those create events matching the query are returned. See\n   * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n   * language.\n   *\n   * @deprecated Prefer `streamQueries`.\n   *\n   * @param template The contract template to match contracts against.\n   * @param query The query to match contracts agains.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.streamQuery = function (template, query) {\n    if (query === undefined) {\n      return this.streamQueryCommon(template, [], \"Ledger.streamQuery\");\n    } else {\n      return this.streamQueryCommon(template, [query], \"Ledger.streamQuery\");\n    }\n  };\n  /**\n   * @internal\n   *\n   */\n\n\n  Ledger.prototype.streamQueryCommon = function (template, queries, name) {\n    if (this.multiplexQueryStreams) {\n      return this.queryStreamsManager.streamSubmit(template, queries, name);\n    } else {\n      var request_3 = queries.length == 0 ? [{\n        templateIds: [template.templateId]\n      }] : queries.map(function (q) {\n        return {\n          templateIds: [template.templateId],\n          query: encodeQuery(template, q)\n        };\n      });\n\n      var reconnectRequest = function () {\n        return request_3;\n      };\n\n      var change = function (contracts, events) {\n        var archiveEvents = new Set();\n        var createEvents = [];\n\n        for (var _i = 0, events_5 = events; _i < events_5.length; _i++) {\n          var event_3 = events_5[_i];\n\n          if (\"created\" in event_3) {\n            createEvents.push(event_3.created);\n          } else if (\"archived\" in event_3) {\n            archiveEvents.add(event_3.archived.contractId);\n          }\n        }\n\n        return contracts.concat(createEvents).filter(function (contract) {\n          return !archiveEvents.has(contract.contractId);\n        });\n      };\n\n      return this.streamSubmit(name, template, \"v1/stream/query\", request_3, reconnectRequest, [], change);\n    }\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and queries.\n   *\n   * If the given list is empty, the accumulated state is the set of all active\n   * contracts for the given template. Otherwise, the accumulated state is the\n   * set of all contracts that match at least one of the given queries.\n   *\n   * See https://docs.daml.com/json-api/search-query-language.html for a\n   * description of the query language.\n   *\n   * @param template The contract template to match contracts against.\n   * @param queries A query to match contracts against.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.streamQueries = function (template, queries) {\n    return this.streamQueryCommon(template, queries, \"Ledger.streamQueries\");\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and contract key.\n   *\n   * The accumulated state is either the current active contract for the given\n   * key, or null if there is no active contract for the given key.\n   *\n   * @deprecated Prefer `streamFetchByKeys`.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.streamFetchByKey = function (template, key) {\n    // Note: this implementation is deliberately not unified with that of\n    // `streamFetchByKeys`, because doing so would add the requirement that the\n    // given key be in output format, whereas existing implementation supports\n    // input format.\n    var lastContractId = null;\n    var request = [{\n      templateId: template.templateId,\n      key: template.keyEncode(key)\n    }];\n\n    var reconnectRequest = function () {\n      return [__assign(__assign({}, request[0]), {\n        contractIdAtOffset: lastContractId && (0, types_1.ContractId)(template).encode(lastContractId)\n      })];\n    };\n\n    var change = function (contract, events) {\n      for (var _i = 0, events_6 = events; _i < events_6.length; _i++) {\n        var event_4 = events_6[_i];\n\n        if (\"created\" in event_4) {\n          contract = event_4.created;\n        } else {\n          // i.e. 'archived' event\n          if (contract && contract.contractId === event_4.archived.contractId) {\n            contract = null;\n          }\n        }\n      }\n\n      lastContractId = contract ? contract.contractId : null;\n      return contract;\n    };\n\n    return this.streamSubmit(\"Ledger.streamFetchByKey\", template, \"v1/stream/fetch\", request, reconnectRequest, null, change);\n  };\n  /**\n   * @internal\n   *\n   * Returns the same API as [[streamSubmit]] but does not, in fact, establish\n   * any socket connection. Instead, this is a stream that always has the given\n   * value as its accumulated state.\n   */\n\n\n  Ledger.prototype.constantStream = function (value) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function on(type, listener) {\n      if (type === \"live\") {\n        listener(value);\n      }\n\n      if (type === \"change\") {\n        listener(value, []);\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n\n\n    function off(_t, _l) {} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    return {\n      on: on,\n      off: off,\n      close: function () {}\n    };\n  };\n  /**\n   * Retrieve a consolidated stream of events for a list of keys and a single\n   * template.\n   *\n   * The accumulated state is an array of the same length as the given list of\n   * keys, with positional correspondence. Each element in the array represents\n   * the current contract for the given key, or is explicitly null if there is\n   * currently no active contract matching that key.\n   *\n   * Note: the given `key` objects will be compared for (deep) equality with\n   * the values returned by the API. As such, they have to be given in the\n   * \"output\" format of the API, including the values of\n   * `encodeDecimalAsString` and `encodeInt64AsString`. See [the JSON API docs\n   * for details](https://docs.daml.com/json-api/lf-value-specification.html).\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.streamFetchByKeys = function (template, keys) {\n    // We support zero-length key so clients can more easily manage a dynamic\n    // list, without having to special-case 0-length on their side.\n    if (keys.length == 0) {\n      return this.constantStream([]);\n    }\n\n    var lastContractIds = Array(keys.length).fill(null);\n    var keysCopy = lodash_1.default.cloneDeep(keys);\n    var initState = Array(keys.length).fill(null);\n    var request = keys.map(function (k) {\n      return {\n        templateId: template.templateId,\n        key: template.keyEncode(k)\n      };\n    });\n\n    var reconnectRequest = function () {\n      return request.map(function (r, idx) {\n        var lastId = lastContractIds[idx];\n        return __assign(__assign({}, r), {\n          contractIdAtOffset: lastId && (0, types_1.ContractId)(template).encode(lastId)\n        });\n      });\n    };\n\n    var change = function (state, events) {\n      var newState = Array.from(state);\n\n      var _loop_1 = function (event_5) {\n        if (\"created\" in event_5) {\n          var k_1 = event_5.created.key;\n          keysCopy.forEach(function (requestKey, idx) {\n            if (lodash_1.default.isEqual(requestKey, k_1)) {\n              newState[idx] = event_5.created;\n            }\n          });\n        } else {\n          // i.e. 'archived' in event\n          var id_1 = event_5.archived.contractId;\n          newState.forEach(function (contract, idx) {\n            if (contract && contract.contractId === id_1) {\n              newState[idx] = null;\n            }\n          });\n        }\n      };\n\n      for (var _i = 0, events_7 = events; _i < events_7.length; _i++) {\n        var event_5 = events_7[_i];\n\n        _loop_1(event_5);\n      }\n\n      newState.forEach(function (c, idx) {\n        lastContractIds[idx] = c ? c.contractId : null;\n      });\n      return newState;\n    };\n\n    return this.streamSubmit(\"streamFetchByKeys\", template, \"v1/stream/fetch\", request, reconnectRequest, initState, change);\n  };\n  /**\n   * Fetch parties by identifier.\n   *\n   * @param parties An array of Party identifiers.\n   *\n   * @returns An array of the same length, where each element corresponds to\n   * the same-index element of the given parties, ans is either a PartyInfo\n   * object if the party exists or null if it does not.\n   *\n   */\n\n\n  Ledger.prototype.getParties = function (parties) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json, resp, mapping, _i, resp_1, p, ret, idx;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (parties.length === 0) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            return [4\n            /*yield*/\n            , this.submit(\"v1/parties\", parties)];\n\n          case 1:\n            json = _a.sent();\n            resp = decode(jtv.array(partyInfoDecoder), json);\n            mapping = {};\n\n            for (_i = 0, resp_1 = resp; _i < resp_1.length; _i++) {\n              p = resp_1[_i];\n              mapping[p.identifier] = p;\n            }\n\n            ret = Array(parties.length).fill(null);\n\n            for (idx = 0; idx < parties.length; idx++) {\n              ret[idx] = mapping[parties[idx]] || null;\n            }\n\n            return [2\n            /*return*/\n            , ret];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch all parties on the ledger.\n   *\n   * @returns All parties on the ledger, in no particular order.\n   *\n   */\n\n\n  Ledger.prototype.listKnownParties = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/parties\", undefined, \"get\")];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(partyInfoDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Get the current user details obtained by the currently used JWT.\n   *\n   * @param userId The user id\n   *\n   * @returns User details\n   *\n   */\n\n\n  Ledger.prototype.getUser = function (userId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(0, lodash_1.isUndefined)(userId)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user\", undefined, \"get\")];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user\", {\n              userId: userId\n            }, \"post\")];\n\n          case 3:\n            _a = _b.sent();\n            _b.label = 4;\n\n          case 4:\n            json = _a;\n            return [2\n            /*return*/\n            , decode(userDecoder, json)];\n        }\n      });\n    });\n  };\n  /**\n   * Lists the users on the ledger\n   *\n   * @returns user list\n   *\n   */\n\n\n  Ledger.prototype.listUsers = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/users\", undefined, \"get\")];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(userDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Lists the rights associated with the given user id\n   *\n   * @param userId, if empty then the user id will obtained by the currently used JWT.\n   *\n   * @returns list of user rights\n   */\n\n\n  Ledger.prototype.listUserRights = function (userId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(0, lodash_1.isUndefined)(userId)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user/rights\", undefined, \"get\")];\n\n          case 1:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user/rights\", {\n              userId: userId\n            })];\n\n          case 3:\n            _a = _b.sent();\n            _b.label = 4;\n\n          case 4:\n            json = _a;\n            return [2\n            /*return*/\n            , decode(jtv.array(userRightDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Grants rights to a user\n   *\n   * @param userId The user to which rights shall be granted\n   *\n   * @param rights The rights which shall be granted\n   *\n   * @returns The rights which actually were granted (if a right was already granted, then it will not be in the return list)\n   */\n\n\n  Ledger.prototype.grantUserRights = function (userId, rights) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user/rights/grant\", {\n              userId: userId,\n              rights: rights\n            })];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(userRightDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Revokes rights from a user\n   *\n   * @param userId The user from which rights shall be revoked\n   *\n   * @param rights The rights which shall be revoked\n   *\n   * @returns The rights which actually were revoked (if a right was already revoked, then it will not be in the return list)\n   */\n\n\n  Ledger.prototype.revokeUserRights = function (userId, rights) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user/rights/revoke\", {\n              userId: userId,\n              rights: rights\n            })];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(userRightDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a user\n   *\n   * @param userId The user ID\n   * @param rights The initial rights the user should have\n   * @param primaryParty The primary party the user should have\n   *\n   */\n\n\n  Ledger.prototype.createUser = function (userId, rights, primaryParty) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user/create\", {\n              userId: userId,\n              rights: rights,\n              primaryParty: primaryParty\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Deletes a user\n   *\n   * @param userId The user ID\n   * @param rights The initial rights the user should have\n   * @param primaryParty The primary party the user should have\n   *\n   */\n\n\n  Ledger.prototype.deleteUser = function (userId) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/user/delete\", {\n              userId: userId\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Allocate a new party.\n   *\n   * @param partyOpt Parameters for party allocation.\n   *\n   * @returns PartyInfo for the newly created party.\n   *\n   */\n\n\n  Ledger.prototype.allocateParty = function (partyOpt) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/parties/allocate\", partyOpt)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(partyInfoDecoder, json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a list of all package IDs from the ledger.\n   *\n   * @returns List of package IDs.\n   *\n   */\n\n\n  Ledger.prototype.listPackages = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit(\"v1/packages\", undefined, \"get\")];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(jtv.string()), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a binary package.\n   *\n   * @returns The content of the package as a raw ArrayBuffer.\n   *\n   */\n\n\n  Ledger.prototype.getPackage = function (id) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , (0, cross_fetch_1.default)(this.httpBaseUrl + \"v1/packages/\" + id, {\n              headers: this.auth(),\n              method: \"get\"\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , httpResponse.arrayBuffer()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Upload a binary archive. Note that this requires admin privileges.\n   *\n   * @returns No return value on success; throws on error.\n   *\n   */\n\n\n  Ledger.prototype.uploadDarFile = function (abuf) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , (0, cross_fetch_1.default)(this.httpBaseUrl + \"v1/packages\", {\n              body: abuf,\n              headers: __assign(__assign({}, this.auth()), {\n                \"Content-type\": \"application/octet-stream\"\n              }),\n              method: \"post\"\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Ledger;\n}();\n\nexports.default = Ledger;","map":{"version":3,"sources":["../../../../../../language-support/ts/daml-ledger/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WsState = exports.assert = exports.UserRightHelper = void 0;\n// Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar types_1 = require(\"@daml/types\");\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nvar events_1 = require(\"events\");\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nvar lodash_1 = __importStar(require(\"lodash\"));\nvar partyInfoDecoder = jtv.object({\n    identifier: jtv.string(),\n    displayName: jtv.optional(jtv.string()),\n    isLocal: jtv.boolean(),\n});\nvar userDecoder = jtv.object({\n    userId: jtv.string(),\n    primaryParty: jtv.optional(jtv.string()),\n});\nvar UserRightHelper = /** @class */ (function () {\n    function UserRightHelper() {\n    }\n    UserRightHelper.canActAs = function (party) {\n        return { type: \"CanActAs\", party: party };\n    };\n    UserRightHelper.canReadAs = function (party) {\n        return { type: \"CanReadAs\", party: party };\n    };\n    UserRightHelper.participantAdmin = {\n        type: \"ParticipantAdmin\",\n    };\n    return UserRightHelper;\n}());\nexports.UserRightHelper = UserRightHelper;\nvar userRightDecoder = jtv.oneOf(jtv.object({\n    type: jtv.constant(\"CanActAs\"),\n    party: jtv.string(),\n}), jtv.object({\n    type: jtv.constant(\"CanReadAs\"),\n    party: jtv.string(),\n}), jtv.object({\n    type: jtv.constant(\"ParticipantAdmin\"),\n}));\nvar decode = function (decoder, data) {\n    return jtv.Result.withException(decoder.run(data));\n};\n/**\n * Decoder for a [[CreateEvent]].\n */\nvar decodeCreateEvent = function (template) {\n    return jtv.object({\n        templateId: jtv.constant(template.templateId),\n        contractId: (0, types_1.ContractId)(template).decoder,\n        signatories: (0, types_1.List)(types_1.Party).decoder,\n        observers: (0, types_1.List)(types_1.Party).decoder,\n        agreementText: types_1.Text.decoder,\n        key: template.keyDecoder,\n        payload: template.decoder,\n    });\n};\n/**\n * Decoder for a [[CreateEvent]] of unknown contract template.\n */\nvar decodeCreateEventUnknown = jtv\n    .valueAt([\"templateId\"], jtv.string())\n    .andThen(function (templateId) { return decodeCreateEvent((0, types_1.lookupTemplate)(templateId)); });\n/**\n * Decoder for an [[ArchiveEvent]].\n */\nvar decodeArchiveEvent = function (template) {\n    return jtv.object({\n        templateId: jtv.constant(template.templateId),\n        contractId: (0, types_1.ContractId)(template).decoder,\n    });\n};\n/**\n * Decoder for an [[ArchiveEvent]] of unknown contract template.\n */\nvar decodeArchiveEventUnknown = jtv\n    .valueAt([\"templateId\"], jtv.string())\n    .andThen(function (templateId) { return decodeArchiveEvent((0, types_1.lookupTemplate)(templateId)); });\n/**\n * Decoder for an [[Event]].\n */\nvar decodeEvent = function (template) {\n    return jtv.oneOf(jtv.object({\n        created: decodeCreateEvent(template),\n        matchedQueries: jtv.array(jtv.number()),\n    }), jtv.object({ created: decodeCreateEvent(template) }), jtv.object({ archived: decodeArchiveEvent(template) }));\n};\n/**\n * Decoder for an [[Event]] with unknown contract template.\n */\nvar decodeEventUnknown = jtv.oneOf(jtv.object({\n    created: decodeCreateEventUnknown,\n    matchedQueries: jtv.array(jtv.number()),\n}), jtv.object({ created: decodeCreateEventUnknown }), jtv.object({ archived: decodeArchiveEventUnknown }));\n/**\n * @internal\n */\nfunction decodeArchiveResponse(template, archiveMethod, \n// eslint-disable-next-line @typescript-eslint/ban-types\narchiveCommand) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, _b, events;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0: return [4 /*yield*/, archiveCommand()];\n                case 1:\n                    _a = _c.sent(), _b = _a[0], events = _a[1];\n                    if (events.length === 1 &&\n                        \"archived\" in events[0] &&\n                        events[0].archived.templateId === template.templateId) {\n                        return [2 /*return*/, events[0].archived];\n                    }\n                    else {\n                        throw Error(\"Ledger.\".concat(archiveMethod, \" is expected to cause one archive event for template \").concat(template.templateId, \"       but caused \").concat(JSON.stringify(events), \".\"));\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * @internal\n */\nfunction isRecordWith(field, x) {\n    return typeof x === \"object\" && x !== null && field in x;\n}\n/**\n *\n * @internal\n */\nfunction isCreateWithMatchedQueries(event) {\n    return isRecordWith(\"created\", event);\n}\n/** @internal\n * exported for testing only\n */\nfunction assert(b, m) {\n    if (!b) {\n        throw m;\n    }\n}\nexports.assert = assert;\n// TODO(MH): Support comparison queries.\n/** @internal\n *\n * Official documentation (docs/source/json-api/search-query-language.rst)\n * currently explicitly forbids the use of lists, textmaps and genmaps in\n * queries. As long as that restriction stays, there is no need for any kind of\n * encoding here.\n */\nfunction encodeQuery(_template, query) {\n    return query;\n}\n/**\n * @internal\n */\nvar decodeLedgerResponse = jtv.object({\n    status: jtv.number(),\n    result: jtv.unknownJson(),\n    warnings: jtv.optional(jtv.unknownJson()),\n});\n/**\n * @internal\n */\nvar decodeLedgerError = jtv.object({\n    status: jtv.number(),\n    errors: jtv.array(jtv.string()),\n    warnings: jtv.optional(jtv.unknownJson()),\n});\nvar StreamEventEmitter = /** @class */ (function (_super) {\n    __extends(StreamEventEmitter, _super);\n    function StreamEventEmitter(_a) {\n        var beforeClosing = _a.beforeClosing;\n        var _this = _super.call(this) || this;\n        _this.beforeClosing = beforeClosing;\n        return _this;\n    }\n    StreamEventEmitter.prototype.close = function () {\n        this.beforeClosing();\n        this.emit(\"close\", { code: 4000, reason: \"called .close()\" });\n        this.removeAllListeners();\n    };\n    return StreamEventEmitter;\n}(events_1.EventEmitter));\nvar NoOffsetReceivedYet = Symbol(\"NoOffsetReceivedYet\");\nvar NullOffsetReceived = Symbol(\"NullOffsetReceived\");\nfunction append(map, key, value) {\n    var _a;\n    if (map.has(key)) {\n        (_a = map.get(key)) === null || _a === void 0 ? void 0 : _a.push(value);\n    }\n    else {\n        map.set(key, [value]);\n    }\n}\n/**\n * @deprecated All usages of this function should be replaced by just\n *             iterating over the iterator. For this to happen, the TS\n *             compiler requires the --downlevelIteration flag, which\n *             however does not play nicely with Jest when running the\n *             tests.\n *\n * TODO Moving the compilation target to ES6 probably would solve this, investigate.\n */\nfunction materialize(iterator) {\n    return Array.from(iterator);\n}\nvar WsState;\n(function (WsState) {\n    WsState[WsState[\"Connecting\"] = 0] = \"Connecting\";\n    WsState[WsState[\"Open\"] = 1] = \"Open\";\n    WsState[WsState[\"Closing\"] = 2] = \"Closing\";\n    WsState[WsState[\"Closed\"] = 3] = \"Closed\";\n})(WsState = exports.WsState || (exports.WsState = {}));\n/**\n * @internal\n *\n * A special handler for stream requests to the /v1/stream/query endpoint.\n * The query endpoint supports providing offsets on a per-query basis.\n * This class leverages this feature by multiplexing virtual streaming requests to a single web socket.\n */\nvar QueryStreamsManager = /** @class */ (function () {\n    function QueryStreamsManager(_a) {\n        var token = _a.token, wsBaseUrl = _a.wsBaseUrl, reconnectThreshold = _a.reconnectThreshold;\n        // Mutable state BEGIN\n        // Ongoing streaming queries that will be the downstream consumers of web socket messages\n        this.queries = new Set();\n        // Lookup tables used to route events to the relevant consumers:\n        //  - consumers for create events can be looked up based on their match index\n        //    - store the offset by which a match indexes needs to be shifted before the event is passed to the consumer\n        //  - archive events can be lookup up by template identifier\n        //    - this causes the consumer to observe what is known as \"phantom archives\", which are known and documented\n        this.matchIndexLookupTable = [];\n        this.templateIdsLookupTable = {};\n        // Accumulates each query in a flattened form to be sent as a single request to the JSON API\n        this.request = [];\n        // to track changes on web socket queries\n        this.wsQueriesChange = false;\n        this.protocols = [\"jwt.token.\" + token, \"daml.ws.auth\"];\n        this.url = wsBaseUrl + QueryStreamsManager.ENDPOINT;\n        this.reconnectThresholdMs = reconnectThreshold;\n    }\n    QueryStreamsManager.toRequest = function (query) {\n        var request = query.queries.length == 0\n            ? [{ templateIds: [query.template.templateId] }]\n            : query.queries.map(function (q) { return ({\n                templateIds: [query.template.templateId],\n                query: encodeQuery(query.template, q),\n            }); });\n        if (typeof query.offset === \"string\") {\n            for (var _i = 0, request_1 = request; _i < request_1.length; _i++) {\n                var r = request_1[_i];\n                r.offset = query.offset;\n            }\n        }\n        return request;\n    };\n    QueryStreamsManager.prototype.resetAllState = function () {\n        // close ws if defined\n        if (this.ws !== undefined) {\n            this.ws.close();\n        }\n        this.queries.clear();\n        this.matchIndexLookupTable = [];\n        this.templateIdsLookupTable = {};\n        this.request = [];\n        this.ws = undefined;\n        this.wsLiveSince = undefined;\n        this.wsQueriesChange = false;\n    };\n    QueryStreamsManager.prototype.handleQueriesChange = function () {\n        //eslint-disable-next-line @typescript-eslint/no-this-alias\n        var manager = this; // stable self-reference for callbacks\n        if (manager.queries.size > 0) {\n            if (manager.ws !== undefined) {\n                //set the queries change flag to true, this should eventually get reset once the ws is closed.\n                manager.wsQueriesChange = true;\n                manager.wsLiveSince = undefined;\n                manager.ws.close();\n                manager.ws = undefined;\n            }\n            var ws = new isomorphic_ws_1.default(manager.url, manager.protocols);\n            var onWsMessage_1 = function (ws) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                return function (_a) {\n                    var data = _a.data;\n                    if (ws.readyState === WsState.Open) {\n                        var json = JSON.parse(data.toString());\n                        if (isRecordWith(\"events\", json)) {\n                            var events = jtv.Result.withException(jtv.array(decodeEventUnknown).run(json.events));\n                            var multiplexer = new Map();\n                            for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n                                var event_1 = events_2[_i];\n                                if (isCreateWithMatchedQueries(event_1)) {\n                                    var consumersToMatchedQueries = new Map();\n                                    for (var _b = 0, _c = event_1.matchedQueries; _b < _c.length; _b++) {\n                                        var matchIndex = _c[_b];\n                                        var _d = manager.matchIndexLookupTable[matchIndex], consumer = _d[0], matchIndexOffset = _d[1];\n                                        append(consumersToMatchedQueries, consumer, matchIndexOffset);\n                                    }\n                                    for (var _e = 0, _f = materialize(consumersToMatchedQueries.entries()); _e < _f.length; _e++) {\n                                        var _g = _f[_e], consumer = _g[0], matchedQueries = _g[1];\n                                        // Create a new copy of the event for each consumer to freely mangle the matched queries and avoid sharing mutable state\n                                        append(multiplexer, consumer, __assign(__assign({}, event_1), { matchedQueries: matchedQueries }));\n                                    }\n                                }\n                                else if (\"archived\" in event_1) {\n                                    var consumers = manager.templateIdsLookupTable[event_1.archived.templateId];\n                                    for (var _h = 0, _j = materialize(consumers.values()); _h < _j.length; _h++) {\n                                        var consumer = _j[_h];\n                                        // Create a new copy of the event for each consumer to avoid sharing mutable state\n                                        append(multiplexer, consumer, __assign({}, event_1));\n                                    }\n                                }\n                                else {\n                                    console.error(\"\".concat(event_1, \" unknown event type received, expected created with matchedQueries or archived\"), json);\n                                }\n                            }\n                            for (var _k = 0, _m = materialize(multiplexer.entries()); _k < _m.length; _k++) {\n                                var _o = _m[_k], consumer = _o[0], events_4 = _o[1];\n                                for (var _p = 0, events_3 = events_4; _p < events_3.length; _p++) {\n                                    var event_2 = events_3[_p];\n                                    if (isCreateWithMatchedQueries(event_2)) {\n                                        consumer.state.set(event_2.created.contractId, event_2.created);\n                                    }\n                                    else if (\"archived\" in event_2) {\n                                        consumer.state.delete(event_2.archived.contractId);\n                                    }\n                                }\n                                consumer.stream.emit(\"change\", Array.from(consumer.state.values()), events_4);\n                            }\n                            if (isRecordWith(\"offset\", json)) {\n                                var offset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n                                if (manager.wsLiveSince === undefined) {\n                                    //on receiving the first offset event we consider the web socket to be live.\n                                    manager.wsLiveSince = Date.now();\n                                }\n                                for (var _q = 0, _r = materialize(manager.queries.values()); _q < _r.length; _q++) {\n                                    var consumer = _r[_q];\n                                    if (!(typeof consumer.offset === \"string\")) {\n                                        // Rebuilding the state array from scratch to make sure mutable state is not shared between the 'change' and 'live' event\n                                        consumer.stream.emit(\"live\", Array.from(consumer.state.values()));\n                                    }\n                                    if (typeof offset === \"string\") {\n                                        consumer.offset = offset;\n                                    }\n                                    else {\n                                        consumer.offset = NullOffsetReceived;\n                                    }\n                                }\n                            }\n                        }\n                        else if (isRecordWith(\"warnings\", json)) {\n                            for (var _s = 0, _u = materialize(manager.queries.values()); _s < _u.length; _s++) {\n                                var query = _u[_s];\n                                console.warn(\"\".concat(query.caller, \" warnings\"), json);\n                            }\n                        }\n                        else if (isRecordWith(\"errors\", json)) {\n                            for (var _v = 0, _w = materialize(manager.queries.values()); _v < _w.length; _v++) {\n                                var query = _w[_v];\n                                console.warn(\"\".concat(query.caller, \" errors\"), json);\n                            }\n                        }\n                        else {\n                            for (var _x = 0, _y = materialize(manager.queries.values()); _x < _y.length; _x++) {\n                                var query = _y[_x];\n                                console.error(\"\".concat(query.caller, \" unknown message\"), json);\n                            }\n                        }\n                    }\n                };\n            };\n            var onWsOpen_1 = function () {\n                var _a;\n                // only make a new websocket request if we have registered queries\n                if (manager.queries.size > 0) {\n                    var newRequests = [];\n                    var newMatchIndexLookupTable = [];\n                    for (var _i = 0, _b = materialize(manager.queries.values()); _i < _b.length; _i++) {\n                        var query = _b[_i];\n                        var request = QueryStreamsManager.toRequest(query);\n                        // Add entries to the lookup table for create events\n                        var matchIndexOffset = newMatchIndexLookupTable.length;\n                        var matchIndexLookupTableEntries = new Array(request.length).fill([query, matchIndexOffset]);\n                        newMatchIndexLookupTable = newMatchIndexLookupTable.concat(matchIndexLookupTableEntries);\n                        // Add entries to the lookup table for archive events\n                        for (var _c = 0, request_2 = request; _c < request_2.length; _c++) {\n                            var templateIds = request_2[_c].templateIds;\n                            for (var _d = 0, templateIds_1 = templateIds; _d < templateIds_1.length; _d++) {\n                                var templateId = templateIds_1[_d];\n                                manager.templateIdsLookupTable[templateId] =\n                                    manager.templateIdsLookupTable[templateId] || new Set();\n                                manager.templateIdsLookupTable[templateId].add(query);\n                            }\n                        }\n                        //since we go through all queries on the manager, we should be safely able to rebuild the whole request\n                        newRequests = newRequests.concat(request);\n                    }\n                    manager.request = newRequests;\n                    manager.matchIndexLookupTable = newMatchIndexLookupTable;\n                    (_a = manager.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(Array.from(manager.request.values())));\n                }\n            };\n            var onWsClose_1 = function () {\n                //if not a web socket queries change then we need to initiate reconnect logic.\n                if (!manager.wsQueriesChange) {\n                    // The web socket has been closed due to an error\n                    // If the conditions are met, attempt to reconnect and/or inform downstream consumers\n                    var now = Date.now();\n                    if (manager.wsLiveSince !== undefined &&\n                        now - manager.wsLiveSince >= manager.reconnectThresholdMs) {\n                        console.log(\"Reconnecting ws, previously liveSince: \".concat(manager.wsLiveSince, \" and reconnectThresholdMs: \").concat(manager.reconnectThresholdMs));\n                        manager.wsLiveSince = undefined;\n                        var ws_1 = new isomorphic_ws_1.default(manager.url, manager.protocols);\n                        ws_1.addEventListener(\"open\", onWsOpen_1);\n                        ws_1.addEventListener(\"message\", onWsMessage_1(ws_1));\n                        ws_1.addEventListener(\"close\", onWsClose_1);\n                        manager.ws = ws_1;\n                    }\n                    else {\n                        // ws has closed too quickly / never managed to connect: we give up\n                        for (var _i = 0, _a = materialize(manager.queries.values()); _i < _a.length; _i++) {\n                            var consumer = _a[_i];\n                            consumer.stream.emit(\"close\", {\n                                code: 4001,\n                                reason: \"ws connection failed\",\n                            });\n                            consumer.stream.removeAllListeners();\n                        }\n                        manager.resetAllState();\n                    }\n                }\n                else {\n                    //this was triggered due to queries change , reset the flag\n                    manager.wsQueriesChange = false;\n                }\n            };\n            // Purposefully ignoring 'error' events; they are always followed by a 'close' event, which needs to be handled anyway\n            ws.addEventListener(\"open\", onWsOpen_1);\n            ws.addEventListener(\"message\", onWsMessage_1(ws));\n            ws.addEventListener(\"close\", onWsClose_1);\n            //eslint-disable-next-line @typescript-eslint/no-this-alias\n            manager.ws = ws;\n        }\n    };\n    QueryStreamsManager.prototype.streamSubmit = function (template, queries, caller) {\n        //eslint-disable-next-line @typescript-eslint/no-this-alias\n        var manager = this;\n        var query = {\n            template: template,\n            queries: queries,\n            stream: new StreamEventEmitter({\n                beforeClosing: function () {\n                    manager.queries.delete(query);\n                    // if no more queries then just let it go\n                    if (manager.queries.size > 0) {\n                        manager.handleQueriesChange();\n                    }\n                },\n            }),\n            state: new Map(),\n            offset: NoOffsetReceivedYet,\n            caller: caller,\n        };\n        manager.queries.add(query);\n        manager.handleQueriesChange();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var on = function (type, listener) {\n            var _a, _b;\n            if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open ||\n                ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n                query.stream.on(type, listener);\n            }\n            else {\n                console.error(\"Trying to add a listener to a closed stream.\");\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var off = function (type, listener) {\n            var _a, _b;\n            if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open ||\n                ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n                query.stream.off(type, listener);\n            }\n            else {\n                console.error(\"Trying to remove a listener from a closed stream.\");\n            }\n        };\n        var close = function () {\n            query.stream.close();\n        };\n        return { on: on, off: off, close: close };\n    };\n    QueryStreamsManager.ENDPOINT = \"v1/stream/query\";\n    return QueryStreamsManager;\n}());\n/**\n * An object of type `Ledger` represents a handle to a Daml ledger.\n */\nvar Ledger = /** @class */ (function () {\n    /**\n     * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.\n     */\n    function Ledger(_a) {\n        var token = _a.token, httpBaseUrl = _a.httpBaseUrl, wsBaseUrl = _a.wsBaseUrl, _b = _a.reconnectThreshold, reconnectThreshold = _b === void 0 ? 30000 : _b, _c = _a.multiplexQueryStreams, multiplexQueryStreams = _c === void 0 ? false : _c;\n        if (!httpBaseUrl) {\n            httpBaseUrl = \"\".concat(window.location.protocol, \"//\").concat(window.location.host, \"/\");\n        }\n        if (!(httpBaseUrl.startsWith(\"http://\") || httpBaseUrl.startsWith(\"https://\"))) {\n            throw Error(\"Ledger: httpBaseUrl must start with 'http://' or 'https://'. (\".concat(httpBaseUrl, \")\"));\n        }\n        if (!httpBaseUrl.endsWith(\"/\")) {\n            throw Error(\"Ledger: httpBaseUrl must end with '/'. (\".concat(httpBaseUrl, \")\"));\n        }\n        if (!wsBaseUrl) {\n            wsBaseUrl = \"ws\" + httpBaseUrl.slice(4);\n        }\n        if (!(wsBaseUrl.startsWith(\"ws://\") || wsBaseUrl.startsWith(\"wss://\"))) {\n            throw Error(\"Ledger: wsBaseUrl must start with 'ws://' or 'wss://'. (\".concat(wsBaseUrl, \")\"));\n        }\n        if (!wsBaseUrl.endsWith(\"/\")) {\n            throw Error(\"Ledger: wsBaseUrl must end with '/'. (\".concat(wsBaseUrl, \")\"));\n        }\n        this.token = token;\n        this.httpBaseUrl = httpBaseUrl;\n        this.wsBaseUrl = wsBaseUrl;\n        this.reconnectThreshold = reconnectThreshold;\n        this.multiplexQueryStreams = multiplexQueryStreams;\n        this.queryStreamsManager = new QueryStreamsManager({\n            token: token,\n            wsBaseUrl: wsBaseUrl,\n            reconnectThreshold: reconnectThreshold,\n        });\n    }\n    /**\n     * @internal\n     */\n    Ledger.prototype.auth = function () {\n        return { Authorization: \"Bearer \" + this.token };\n    };\n    /**\n     * @internal\n     */\n    Ledger.prototype.throwOnError = function (r) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!r.ok) return [3 /*break*/, 2];\n                        return [4 /*yield*/, r.json()];\n                    case 1:\n                        json = _a.sent();\n                        console.log(json);\n                        throw decode(decodeLedgerError, json);\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @internal\n     *\n     * Internal function to submit a command to the JSON API.\n     */\n    Ledger.prototype.submit = function (endpoint, payload, method) {\n        if (method === void 0) { method = \"post\"; }\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse, json, ledgerResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0, cross_fetch_1.default)(this.httpBaseUrl + endpoint, {\n                            body: JSON.stringify(payload),\n                            headers: __assign(__assign({}, this.auth()), { \"Content-type\": \"application/json\" }),\n                            method: method,\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, httpResponse.json()];\n                    case 3:\n                        json = _a.sent();\n                        ledgerResponse = jtv.Result.withException(decodeLedgerResponse.run(json));\n                        if (ledgerResponse.warnings) {\n                            console.warn(ledgerResponse.warnings);\n                        }\n                        return [2 /*return*/, ledgerResponse.result];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve contracts for a given template.\n     *\n     * When no `query` argument is given, all contracts visible to the submitting party are returned.\n     * When a `query` argument is given, only those contracts matching the query are returned. See\n     * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n     * language.\n     *\n     * @param template The contract template of the contracts to be matched against.\n     * @param query The contract query for the contracts to be matched against.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.query = function (template, query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = {\n                            templateIds: [template.templateId],\n                            query: encodeQuery(template, query),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/query\", payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.array(decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a contract identified by its contract ID.\n     *\n     * @param template The template of the contract to be fetched.\n     * @param contractId The contract id of the contract to be fetched.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.fetch = function (template, contractId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = {\n                            templateId: template.templateId,\n                            contractId: (0, types_1.ContractId)(template).encode(contractId),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/fetch\", payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a contract identified by its contract key.\n     *\n     * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of\n     * its contract id.\n     *\n     * @param template The template of the contract to be fetched.\n     * @param key The contract key of the contract to be fetched.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.fetchByKey = function (template, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (key === undefined) {\n                            throw Error(\"Cannot lookup by key on template \".concat(template.templateId, \" because it does not define a key.\"));\n                        }\n                        payload = {\n                            templateId: template.templateId,\n                            key: template.keyEncode(key),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/fetch\", payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Create a contract for a given template.\n     *\n     * @param template The template of the contract to be created.\n     * @param payload The template arguments for the contract to be created.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.create = function (template, payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var command, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        command = {\n                            templateId: template.templateId,\n                            payload: template.encode(payload),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/create\", command)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(decodeCreateEvent(template).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Exercise a choice on a contract identified by its contract ID.\n     *\n     * @param choice The choice to exercise.\n     * @param contractId The contract id of the contract to exercise.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     *\n     * @returns The return value of the choice together with a list of\n     * [[event]]'s that were created as a result of exercising the choice.\n     */\n    Ledger.prototype.exercise = function (choice, contractId, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        payload = {\n                            templateId: choice.template().templateId,\n                            contractId: (0, types_1.ContractId)(choice.template()).encode(contractId),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/exercise\", payload)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Exercse a choice on a newly-created contract, in a single transaction.\n     *\n     * @param choice The choice to exercise.\n     * @param payload The template arguments for the newly-created contract.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     *\n     * @returns The return value of the choice together with a list of\n     * [[event]]'s that includes the creation event for the created contract as\n     * well as all the events that were created as a result of exercising the\n     * choice, including the archive event for the created contract if the choice\n     * is consuming (or otherwise archives it as part of its execution).\n     *\n     */\n    Ledger.prototype.createAndExercise = function (choice, payload, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var command, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        command = {\n                            templateId: choice.template().templateId,\n                            payload: choice.template().encode(payload),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/create-and-exercise\", command)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Exercise a choice on a contract identified by its contract key.\n     *\n     * Same as [[exercise]], but the contract is identified by its contract key instead of its\n     * contract id.\n     *\n     * @param choice The choice to exercise.\n     * @param key The contract key of the contract to exercise.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     * @typeparam K The type of the contract key.\n     *\n     * @returns The return value of the choice together with a list of [[event]]'s that where created\n     * as a result of exercising the choice.\n     */\n    Ledger.prototype.exerciseByKey = function (choice, key, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (key === undefined) {\n                            throw Error(\"Cannot exercise by key on template \".concat(choice.template().templateId, \" because it does not define a key.\"));\n                        }\n                        payload = {\n                            templateId: choice.template().templateId,\n                            key: choice.template().keyEncode(key),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit(\"v1/exercise\", payload)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Archive a contract identified by its contract ID.\n     *\n     * @param template The template of the contract to archive.\n     * @param contractId The contract id of the contract to archive.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.archive = function (template, contractId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, decodeArchiveResponse(template, \"archive\", function () {\n                        return _this.exercise(template.Archive, contractId, {});\n                    })];\n            });\n        });\n    };\n    /**\n     * Archive a contract identified by its contract key.\n     * Same as [[archive]], but the contract to be archived is identified by its contract key.\n     *\n     * @param template The template of the contract to be archived.\n     * @param key The contract key of the contract to be archived.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.archiveByKey = function (template, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, decodeArchiveResponse(template, \"archiveByKey\", function () {\n                        return _this.exerciseByKey(template.Archive, key, {});\n                    })];\n            });\n        });\n    };\n    /**\n     * @internal\n     *\n     * Internal command to submit a request to a streaming endpoint of the\n     * JSON API. Returns a stream consisting of accumulated state together with\n     * the events that produced the latest state change. The `change` function\n     * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,\n     * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we\n     * must have the structural equalities\n     * ```\n     * change(s, []) == s\n     * change(s, x.concat(y)) == change(change(s, x), y)\n     * ```\n     * Also, `change` must never change its arguments.\n     */\n    Ledger.prototype.streamSubmit = function (callerName, template, endpoint, request, reconnectRequest, init, change) {\n        var _this = this;\n        var protocols = [\"jwt.token.\" + this.token, \"daml.ws.auth\"];\n        var ws = new isomorphic_ws_1.default(this.wsBaseUrl + endpoint, protocols);\n        var isLiveSince = undefined;\n        var lastOffset = undefined;\n        var state = init;\n        var isReconnecting = false;\n        var streamClosed = false;\n        var emitter = new events_1.EventEmitter();\n        var onWsOpen = function () {\n            if (isReconnecting) {\n                // the JSON API server can't handle null offsets, even though it sends them out under\n                // special conditions when there are no transactions yet. Not sending the `offset` message\n                // will start the stream from the very beginning of the transaction log.\n                if (lastOffset !== null)\n                    ws.send(JSON.stringify({ offset: lastOffset }));\n                ws.send(JSON.stringify(reconnectRequest()));\n            }\n            else {\n                ws.send(JSON.stringify(request));\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var onWsMessage = function (event) {\n            var json = JSON.parse(event.data.toString());\n            if (isRecordWith(\"events\", json)) {\n                var events = jtv.Result.withException(jtv.array(decodeEvent(template)).run(json.events));\n                if (events.length > 0) {\n                    state = change(state, events);\n                    emitter.emit(\"change\", state, events);\n                }\n                if (isRecordWith(\"offset\", json)) {\n                    lastOffset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n                    if (isLiveSince === undefined) {\n                        isLiveSince = Date.now();\n                        emitter.emit(\"live\", state);\n                    }\n                }\n            }\n            else if (isRecordWith(\"warnings\", json)) {\n                console.warn(\"\".concat(callerName, \" warnings\"), json);\n            }\n            else if (isRecordWith(\"errors\", json)) {\n                console.error(\"\".concat(callerName, \" errors\"), json);\n            }\n            else {\n                console.error(\"\".concat(callerName, \" unknown message\"), json);\n            }\n        };\n        var closeStream = function (status) {\n            streamClosed = true;\n            emitter.emit(\"close\", status);\n            emitter.removeAllListeners();\n        };\n        var onWsClose = function () {\n            if (streamClosed === false) {\n                var now = new Date().getTime();\n                // we want to try and keep the stream open, so we try to reconnect\n                // the underlying ws\n                if (lastOffset !== undefined &&\n                    isLiveSince !== undefined &&\n                    now - isLiveSince >= _this.reconnectThreshold) {\n                    isLiveSince = undefined;\n                    isReconnecting = true;\n                    ws = new isomorphic_ws_1.default(_this.wsBaseUrl + endpoint, protocols);\n                    ws.addEventListener(\"open\", onWsOpen);\n                    ws.addEventListener(\"message\", onWsMessage);\n                    ws.addEventListener(\"close\", onWsClose);\n                }\n                else {\n                    // ws has closed too quickly / never managed to connect: we give up\n                    closeStream({ code: 4001, reason: \"ws connection failed\" });\n                }\n            } // no else: if the stream is closed we don't need to keep a ws\n        };\n        ws.addEventListener(\"open\", onWsOpen);\n        ws.addEventListener(\"message\", onWsMessage);\n        // NOTE(MH): We ignore the 'error' event since it is always followed by a\n        // 'close' event, which we need to handle anyway.\n        ws.addEventListener(\"close\", onWsClose);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var on = function (type, listener) {\n            if (streamClosed === false) {\n                void emitter.on(type, listener);\n            }\n            else {\n                console.error(\"Trying to add a listener to a closed stream.\");\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var off = function (type, listener) {\n            if (streamClosed === false) {\n                void emitter.off(type, listener);\n            }\n            else {\n                console.error(\"Trying to remove a listener from a closed stream.\");\n            }\n        };\n        var close = function () {\n            // Note: ws.close will trigger the onClose handlers of the WebSocket\n            // (here onWsClose), but they execute as a separate event after the\n            // current event in the JS event loop, i.e. in particular after the call\n            // to closeStream and thus, in this case, the onWsClose handler will see\n            // streamClosed as true.\n            ws.close();\n            closeStream({ code: 4000, reason: \"called .close()\" });\n        };\n        return { on: on, off: off, close: close };\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and query.\n     *\n     * The accumulated state is the current set of active contracts matching the query. When no\n     * `query` argument is given, all events visible to the submitting party are returned. When a\n     * `query` argument is given, only those create events matching the query are returned. See\n     * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n     * language.\n     *\n     * @deprecated Prefer `streamQueries`.\n     *\n     * @param template The contract template to match contracts against.\n     * @param query The query to match contracts agains.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.streamQuery = function (template, query) {\n        if (query === undefined) {\n            return this.streamQueryCommon(template, [], \"Ledger.streamQuery\");\n        }\n        else {\n            return this.streamQueryCommon(template, [query], \"Ledger.streamQuery\");\n        }\n    };\n    /**\n     * @internal\n     *\n     */\n    Ledger.prototype.streamQueryCommon = function (template, queries, name) {\n        if (this.multiplexQueryStreams) {\n            return this.queryStreamsManager.streamSubmit(template, queries, name);\n        }\n        else {\n            var request_3 = queries.length == 0\n                ? [{ templateIds: [template.templateId] }]\n                : queries.map(function (q) { return ({\n                    templateIds: [template.templateId],\n                    query: encodeQuery(template, q),\n                }); });\n            var reconnectRequest = function () { return request_3; };\n            var change = function (contracts, events) {\n                var archiveEvents = new Set();\n                var createEvents = [];\n                for (var _i = 0, events_5 = events; _i < events_5.length; _i++) {\n                    var event_3 = events_5[_i];\n                    if (\"created\" in event_3) {\n                        createEvents.push(event_3.created);\n                    }\n                    else if (\"archived\" in event_3) {\n                        archiveEvents.add(event_3.archived.contractId);\n                    }\n                }\n                return contracts\n                    .concat(createEvents)\n                    .filter(function (contract) { return !archiveEvents.has(contract.contractId); });\n            };\n            return this.streamSubmit(name, template, \"v1/stream/query\", request_3, reconnectRequest, [], change);\n        }\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and queries.\n     *\n     * If the given list is empty, the accumulated state is the set of all active\n     * contracts for the given template. Otherwise, the accumulated state is the\n     * set of all contracts that match at least one of the given queries.\n     *\n     * See https://docs.daml.com/json-api/search-query-language.html for a\n     * description of the query language.\n     *\n     * @param template The contract template to match contracts against.\n     * @param queries A query to match contracts against.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.streamQueries = function (template, queries) {\n        return this.streamQueryCommon(template, queries, \"Ledger.streamQueries\");\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and contract key.\n     *\n     * The accumulated state is either the current active contract for the given\n     * key, or null if there is no active contract for the given key.\n     *\n     * @deprecated Prefer `streamFetchByKeys`.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.streamFetchByKey = function (template, key) {\n        // Note: this implementation is deliberately not unified with that of\n        // `streamFetchByKeys`, because doing so would add the requirement that the\n        // given key be in output format, whereas existing implementation supports\n        // input format.\n        var lastContractId = null;\n        var request = [\n            { templateId: template.templateId, key: template.keyEncode(key) },\n        ];\n        var reconnectRequest = function () { return [\n            __assign(__assign({}, request[0]), { contractIdAtOffset: lastContractId && (0, types_1.ContractId)(template).encode(lastContractId) }),\n        ]; };\n        var change = function (contract, events) {\n            for (var _i = 0, events_6 = events; _i < events_6.length; _i++) {\n                var event_4 = events_6[_i];\n                if (\"created\" in event_4) {\n                    contract = event_4.created;\n                }\n                else {\n                    // i.e. 'archived' event\n                    if (contract && contract.contractId === event_4.archived.contractId) {\n                        contract = null;\n                    }\n                }\n            }\n            lastContractId = contract ? contract.contractId : null;\n            return contract;\n        };\n        return this.streamSubmit(\"Ledger.streamFetchByKey\", template, \"v1/stream/fetch\", request, reconnectRequest, null, change);\n    };\n    /**\n     * @internal\n     *\n     * Returns the same API as [[streamSubmit]] but does not, in fact, establish\n     * any socket connection. Instead, this is a stream that always has the given\n     * value as its accumulated state.\n     */\n    Ledger.prototype.constantStream = function (value) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function on(type, listener) {\n            if (type === \"live\") {\n                listener(value);\n            }\n            if (type === \"change\") {\n                listener(value, []);\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n        function off(_t, _l) { }\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return { on: on, off: off, close: function () { } };\n    };\n    /**\n     * Retrieve a consolidated stream of events for a list of keys and a single\n     * template.\n     *\n     * The accumulated state is an array of the same length as the given list of\n     * keys, with positional correspondence. Each element in the array represents\n     * the current contract for the given key, or is explicitly null if there is\n     * currently no active contract matching that key.\n     *\n     * Note: the given `key` objects will be compared for (deep) equality with\n     * the values returned by the API. As such, they have to be given in the\n     * \"output\" format of the API, including the values of\n     * `encodeDecimalAsString` and `encodeInt64AsString`. See [the JSON API docs\n     * for details](https://docs.daml.com/json-api/lf-value-specification.html).\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.streamFetchByKeys = function (template, keys) {\n        // We support zero-length key so clients can more easily manage a dynamic\n        // list, without having to special-case 0-length on their side.\n        if (keys.length == 0) {\n            return this.constantStream([]);\n        }\n        var lastContractIds = Array(keys.length).fill(null);\n        var keysCopy = lodash_1.default.cloneDeep(keys);\n        var initState = Array(keys.length).fill(null);\n        var request = keys.map(function (k) { return ({\n            templateId: template.templateId,\n            key: template.keyEncode(k),\n        }); });\n        var reconnectRequest = function () {\n            return request.map(function (r, idx) {\n                var lastId = lastContractIds[idx];\n                return __assign(__assign({}, r), { contractIdAtOffset: lastId && (0, types_1.ContractId)(template).encode(lastId) });\n            });\n        };\n        var change = function (state, events) {\n            var newState = Array.from(state);\n            var _loop_1 = function (event_5) {\n                if (\"created\" in event_5) {\n                    var k_1 = event_5.created.key;\n                    keysCopy.forEach(function (requestKey, idx) {\n                        if (lodash_1.default.isEqual(requestKey, k_1)) {\n                            newState[idx] = event_5.created;\n                        }\n                    });\n                }\n                else {\n                    // i.e. 'archived' in event\n                    var id_1 = event_5.archived.contractId;\n                    newState.forEach(function (contract, idx) {\n                        if (contract && contract.contractId === id_1) {\n                            newState[idx] = null;\n                        }\n                    });\n                }\n            };\n            for (var _i = 0, events_7 = events; _i < events_7.length; _i++) {\n                var event_5 = events_7[_i];\n                _loop_1(event_5);\n            }\n            newState.forEach(function (c, idx) {\n                lastContractIds[idx] = c ? c.contractId : null;\n            });\n            return newState;\n        };\n        return this.streamSubmit(\"streamFetchByKeys\", template, \"v1/stream/fetch\", request, reconnectRequest, initState, change);\n    };\n    /**\n     * Fetch parties by identifier.\n     *\n     * @param parties An array of Party identifiers.\n     *\n     * @returns An array of the same length, where each element corresponds to\n     * the same-index element of the given parties, ans is either a PartyInfo\n     * object if the party exists or null if it does not.\n     *\n     */\n    Ledger.prototype.getParties = function (parties) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json, resp, mapping, _i, resp_1, p, ret, idx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (parties.length === 0) {\n                            return [2 /*return*/, []];\n                        }\n                        return [4 /*yield*/, this.submit(\"v1/parties\", parties)];\n                    case 1:\n                        json = _a.sent();\n                        resp = decode(jtv.array(partyInfoDecoder), json);\n                        mapping = {};\n                        for (_i = 0, resp_1 = resp; _i < resp_1.length; _i++) {\n                            p = resp_1[_i];\n                            mapping[p.identifier] = p;\n                        }\n                        ret = Array(parties.length).fill(null);\n                        for (idx = 0; idx < parties.length; idx++) {\n                            ret[idx] = mapping[parties[idx]] || null;\n                        }\n                        return [2 /*return*/, ret];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch all parties on the ledger.\n     *\n     * @returns All parties on the ledger, in no particular order.\n     *\n     */\n    Ledger.prototype.listKnownParties = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/parties\", undefined, \"get\")];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(partyInfoDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Get the current user details obtained by the currently used JWT.\n     *\n     * @param userId The user id\n     *\n     * @returns User details\n     *\n     */\n    Ledger.prototype.getUser = function (userId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(0, lodash_1.isUndefined)(userId)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.submit(\"v1/user\", undefined, \"get\")];\n                    case 1:\n                        _a = _b.sent();\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, this.submit(\"v1/user\", { userId: userId }, \"post\")];\n                    case 3:\n                        _a = _b.sent();\n                        _b.label = 4;\n                    case 4:\n                        json = _a;\n                        return [2 /*return*/, decode(userDecoder, json)];\n                }\n            });\n        });\n    };\n    /**\n     * Lists the users on the ledger\n     *\n     * @returns user list\n     *\n     */\n    Ledger.prototype.listUsers = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/users\", undefined, \"get\")];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(userDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Lists the rights associated with the given user id\n     *\n     * @param userId, if empty then the user id will obtained by the currently used JWT.\n     *\n     * @returns list of user rights\n     */\n    Ledger.prototype.listUserRights = function (userId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!(0, lodash_1.isUndefined)(userId)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.submit(\"v1/user/rights\", undefined, \"get\")];\n                    case 1:\n                        _a = _b.sent();\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, this.submit(\"v1/user/rights\", { userId: userId })];\n                    case 3:\n                        _a = _b.sent();\n                        _b.label = 4;\n                    case 4:\n                        json = _a;\n                        return [2 /*return*/, decode(jtv.array(userRightDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Grants rights to a user\n     *\n     * @param userId The user to which rights shall be granted\n     *\n     * @param rights The rights which shall be granted\n     *\n     * @returns The rights which actually were granted (if a right was already granted, then it will not be in the return list)\n     */\n    Ledger.prototype.grantUserRights = function (userId, rights) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/user/rights/grant\", {\n                            userId: userId,\n                            rights: rights,\n                        })];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(userRightDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Revokes rights from a user\n     *\n     * @param userId The user from which rights shall be revoked\n     *\n     * @param rights The rights which shall be revoked\n     *\n     * @returns The rights which actually were revoked (if a right was already revoked, then it will not be in the return list)\n     */\n    Ledger.prototype.revokeUserRights = function (userId, rights) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/user/rights/revoke\", {\n                            userId: userId,\n                            rights: rights,\n                        })];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(userRightDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Creates a user\n     *\n     * @param userId The user ID\n     * @param rights The initial rights the user should have\n     * @param primaryParty The primary party the user should have\n     *\n     */\n    Ledger.prototype.createUser = function (userId, rights, primaryParty) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/user/create\", {\n                            userId: userId,\n                            rights: rights,\n                            primaryParty: primaryParty,\n                        })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Deletes a user\n     *\n     * @param userId The user ID\n     * @param rights The initial rights the user should have\n     * @param primaryParty The primary party the user should have\n     *\n     */\n    Ledger.prototype.deleteUser = function (userId) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/user/delete\", { userId: userId })];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Allocate a new party.\n     *\n     * @param partyOpt Parameters for party allocation.\n     *\n     * @returns PartyInfo for the newly created party.\n     *\n     */\n    Ledger.prototype.allocateParty = function (partyOpt) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/parties/allocate\", partyOpt)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(partyInfoDecoder, json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a list of all package IDs from the ledger.\n     *\n     * @returns List of package IDs.\n     *\n     */\n    Ledger.prototype.listPackages = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit(\"v1/packages\", undefined, \"get\")];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(jtv.string()), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a binary package.\n     *\n     * @returns The content of the package as a raw ArrayBuffer.\n     *\n     */\n    Ledger.prototype.getPackage = function (id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0, cross_fetch_1.default)(this.httpBaseUrl + \"v1/packages/\" + id, {\n                            headers: this.auth(),\n                            method: \"get\",\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, httpResponse.arrayBuffer()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Upload a binary archive. Note that this requires admin privileges.\n     *\n     * @returns No return value on success; throws on error.\n     *\n     */\n    Ledger.prototype.uploadDarFile = function (abuf) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, (0, cross_fetch_1.default)(this.httpBaseUrl + \"v1/packages\", {\n                            body: abuf,\n                            headers: __assign(__assign({}, this.auth()), { \"Content-type\": \"application/octet-stream\" }),\n                            method: \"post\",\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Ledger;\n}());\nexports.default = Ledger;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}