{"ast":null,"code":"\"use strict\"; // Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useReload = exports.useStreamFetchByKeys = exports.useStreamFetchByKey = exports.useStreamQueries = exports.useStreamQuery = exports.useFetchByKey = exports.useFetch = exports.useQuery = exports.useLedger = exports.useUser = exports.useParty = exports.DamlLedger = void 0;\n\nvar createLedgerContext_1 = require(\"./createLedgerContext\");\n/**\n * @internal\n */\n\n\nvar ledgerContext = (0, createLedgerContext_1.createLedgerContext)();\n/**\n * Within a `DamlLedger` one can use the hooks provided here.\n *\n * @param props React props and children for this element.\n */\n\nfunction DamlLedger(props) {\n  return ledgerContext.DamlLedger(props);\n}\n\nexports.DamlLedger = DamlLedger;\n/**\n * React hook to get the party currently connected to the ledger.\n */\n\nfunction useParty() {\n  return ledgerContext.useParty();\n}\n\nexports.useParty = useParty;\n/**\n * React hook to get the user currently connected to the ledger participant.\n */\n\nfunction useUser() {\n  return ledgerContext.useUser();\n}\n\nexports.useUser = useUser;\n/**\n * React Hook that returns the Ledger instance to interact with the connected Daml ledger.\n */\n\nfunction useLedger() {\n  return ledgerContext.useLedger();\n}\n\nexports.useLedger = useLedger;\n\nfunction useQuery(template, queryFactory, queryDeps) {\n  return ledgerContext.useQuery(template, queryFactory, queryDeps);\n}\n\nexports.useQuery = useQuery;\n/**\n * React Hook for a lookup by contractId against the `/v1/fetch` endpoint of the JSON API.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contract to fetch.\n * @param contractId The contractId to fetch.\n *\n * @return The fetched contract.\n */\n\nfunction useFetch(template, contractId) {\n  return ledgerContext.useFetch(template, contractId);\n}\n\nexports.useFetch = useFetch;\n/**\n * React Hook for a lookup by key against the `/v1/fetch` endpoint of the JSON API.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to fetch.\n * @param keyFactory A function returning the contract key of the contracts to fetch.\n * @param keyDeps Dependencies of this hook (for which the fetch is reexecuted on change).\n *\n * @return The fetched contract.\n */\n\nfunction useFetchByKey(template, keyFactory, keyDeps) {\n  return ledgerContext.useFetchByKey(template, keyFactory, keyDeps);\n}\n\nexports.useFetchByKey = useFetchByKey;\n/**\n * React Hook to query the ledger, the returned result is updated as the ledger state changes.\n *\n * @deprecated prefer useStreamQueries\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param queryFactory A function returning a query. If the query is omitted, all visible contracts of the given template are returned.\n * @param queryDeps The dependencies of the query (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return The matching contracts.\n */\n\nfunction useStreamQuery(template, queryFactory, queryDeps, closeHandler) {\n  return ledgerContext.useStreamQuery(template, queryFactory, queryDeps, closeHandler);\n}\n\nexports.useStreamQuery = useStreamQuery;\n/**\n * React Hook to query the ledger, the returned result is updated as the ledger state changes.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param queryFactory A function returning an array of queries. If no queryFactory is given, or if the given factory returns an empty array, all visible contracts of the given template are returned. Otherwise, returns a union of all the contracts that match at least one of the given queries.\n * @param queryDeps The dependencies of the query (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return The matching contracts.\n */\n\nfunction useStreamQueries(template, queryFactory, queryDeps, closeHandler) {\n  return ledgerContext.useStreamQueries(template, queryFactory, queryDeps, closeHandler);\n}\n\nexports.useStreamQueries = useStreamQueries;\n/**\n * React Hook to query the ledger. Same as useStreamQuery, but query by contract key instead.\n *\n * @deprecated prefer useStreamFetchByKeys\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param keyFactory A function returning a contract key. Contract\n *        keys must be in \"output\" format as defined in the [JSON API\n *        docs](https://docs.daml.com/json-api/lf-value-specification.html),\n *        i.e., have to match the types generated by the daml-types library.\n * @param keyDeps The dependencies of the fetch-by-key (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return The matching (unique) contract, or null.\n */\n\nfunction useStreamFetchByKey(template, keyFactory, keyDeps, closeHandler) {\n  return ledgerContext.useStreamFetchByKey(template, keyFactory, keyDeps, closeHandler);\n}\n\nexports.useStreamFetchByKey = useStreamFetchByKey;\n/**\n * React Hook to query the ledger. Same as useStreamQueries, but query by contract keys instead.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param keyFactory A function returning an array of contract keys. Contract\n *        keys must be in \"output\" format as defined in the [JSON API\n *        docs](https://docs.daml.com/json-api/lf-value-specification.html),\n *        i.e., have to match the types generated by the daml-types library.\n * @param keyDeps The dependencies of the fetch-by-key (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return An array of the same length as the given array of keys, where each\n *         element is either the currently active contract that matches the\n *         corresponding key, or null if no active contract matches the key in\n *         the same position.\n */\n\nfunction useStreamFetchByKeys(template, keyFactory, keyDeps, closeHandler) {\n  return ledgerContext.useStreamFetchByKeys(template, keyFactory, keyDeps, closeHandler);\n}\n\nexports.useStreamFetchByKeys = useStreamFetchByKeys;\n/**\n * React Hook to reload all active queries.\n */\n\nfunction useReload() {\n  return ledgerContext.useReload();\n}\n\nexports.useReload = useReload;","map":{"version":3,"sources":["../../../../../../language-support/ts/daml-react/defaultLedgerContext.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;AAEA,IAAA,qBAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;AAUA;;AAEG;;;AACH,IAAM,aAAa,GAAG,CAAA,GAAA,qBAAA,CAAA,mBAAA,GAAtB;AAEA;;;;AAIG;;AACH,SAAgB,UAAhB,CACE,KADF,EAC6C;AAE3C,SAAO,aAAa,CAAC,UAAd,CAAyB,KAAzB,CAAP;AACD;;AAJD,OAAA,CAAA,UAAA,GAAA,UAAA;AAMA;;AAEG;;AACH,SAAgB,QAAhB,GAAwB;AACtB,SAAO,aAAa,CAAC,QAAd,EAAP;AACD;;AAFD,OAAA,CAAA,QAAA,GAAA,QAAA;AAIA;;AAEG;;AACH,SAAgB,OAAhB,GAAuB;AACrB,SAAO,aAAa,CAAC,OAAd,EAAP;AACD;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA;AAIA;;AAEG;;AACH,SAAgB,SAAhB,GAAyB;AACvB,SAAO,aAAa,CAAC,SAAd,EAAP;AACD;;AAFD,OAAA,CAAA,SAAA,GAAA,SAAA;;AAyBA,SAAgB,QAAhB,CACE,QADF,EAEE,YAFF,EAGE,SAHF,EAGgC;AAE9B,SAAO,aAAa,CAAC,QAAd,CAAuB,QAAvB,EAAiC,YAAjC,EAA+C,SAA/C,CAAP;AACD;;AAND,OAAA,CAAA,QAAA,GAAA,QAAA;AAQA;;;;;;;;;;;AAWG;;AACH,SAAgB,QAAhB,CACE,QADF,EAEE,UAFF,EAE2B;AAEzB,SAAO,aAAa,CAAC,QAAd,CAAuB,QAAvB,EAAiC,UAAjC,CAAP;AACD;;AALD,OAAA,CAAA,QAAA,GAAA,QAAA;AAOA;;;;;;;;;;;;AAYG;;AACH,SAAgB,aAAhB,CACE,QADF,EAEE,UAFF,EAGE,OAHF,EAG6B;AAE3B,SAAO,aAAa,CAAC,aAAd,CAA4B,QAA5B,EAAsC,UAAtC,EAAkD,OAAlD,CAAP;AACD;;AAND,OAAA,CAAA,aAAA,GAAA,aAAA;AAQA;;;;;;;;;;;;;;;AAeG;;AACH,SAAgB,cAAhB,CACE,QADF,EAEE,YAFF,EAGE,SAHF,EAIE,YAJF,EAI8C;AAE5C,SAAO,aAAa,CAAC,cAAd,CACL,QADK,EAEL,YAFK,EAGL,SAHK,EAIL,YAJK,CAAP;AAMD;;AAZD,OAAA,CAAA,cAAA,GAAA,cAAA;AAcA;;;;;;;;;;;;;AAaG;;AACH,SAAgB,gBAAhB,CACE,QADF,EAEE,YAFF,EAGE,SAHF,EAIE,YAJF,EAI8C;AAE5C,SAAO,aAAa,CAAC,gBAAd,CACL,QADK,EAEL,YAFK,EAGL,SAHK,EAIL,YAJK,CAAP;AAMD;;AAZD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAcA;;;;;;;;;;;;;;;;;;AAkBG;;AACH,SAAgB,mBAAhB,CACE,QADF,EAEE,UAFF,EAGE,OAHF,EAIE,YAJF,EAI8C;AAE5C,SAAO,aAAa,CAAC,mBAAd,CACL,QADK,EAEL,UAFK,EAGL,OAHK,EAIL,YAJK,CAAP;AAMD;;AAZD,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAcA;;;;;;;;;;;;;;;;;;;AAmBG;;AACH,SAAgB,oBAAhB,CACE,QADF,EAEE,UAFF,EAGE,OAHF,EAIE,YAJF,EAI8C;AAE5C,SAAO,aAAa,CAAC,oBAAd,CACL,QADK,EAEL,UAFK,EAGL,OAHK,EAIL,YAJK,CAAP;AAMD;;AAZD,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAcA;;AAEG;;AACH,SAAgB,SAAhB,GAAyB;AACvB,SAAO,aAAa,CAAC,SAAd,EAAP;AACD;;AAFD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useReload = exports.useStreamFetchByKeys = exports.useStreamFetchByKey = exports.useStreamQueries = exports.useStreamQuery = exports.useFetchByKey = exports.useFetch = exports.useQuery = exports.useLedger = exports.useUser = exports.useParty = exports.DamlLedger = void 0;\nvar createLedgerContext_1 = require(\"./createLedgerContext\");\n/**\n * @internal\n */\nvar ledgerContext = (0, createLedgerContext_1.createLedgerContext)();\n/**\n * Within a `DamlLedger` one can use the hooks provided here.\n *\n * @param props React props and children for this element.\n */\nfunction DamlLedger(props) {\n    return ledgerContext.DamlLedger(props);\n}\nexports.DamlLedger = DamlLedger;\n/**\n * React hook to get the party currently connected to the ledger.\n */\nfunction useParty() {\n    return ledgerContext.useParty();\n}\nexports.useParty = useParty;\n/**\n * React hook to get the user currently connected to the ledger participant.\n */\nfunction useUser() {\n    return ledgerContext.useUser();\n}\nexports.useUser = useUser;\n/**\n * React Hook that returns the Ledger instance to interact with the connected Daml ledger.\n */\nfunction useLedger() {\n    return ledgerContext.useLedger();\n}\nexports.useLedger = useLedger;\nfunction useQuery(template, queryFactory, queryDeps) {\n    return ledgerContext.useQuery(template, queryFactory, queryDeps);\n}\nexports.useQuery = useQuery;\n/**\n * React Hook for a lookup by contractId against the `/v1/fetch` endpoint of the JSON API.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contract to fetch.\n * @param contractId The contractId to fetch.\n *\n * @return The fetched contract.\n */\nfunction useFetch(template, contractId) {\n    return ledgerContext.useFetch(template, contractId);\n}\nexports.useFetch = useFetch;\n/**\n * React Hook for a lookup by key against the `/v1/fetch` endpoint of the JSON API.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to fetch.\n * @param keyFactory A function returning the contract key of the contracts to fetch.\n * @param keyDeps Dependencies of this hook (for which the fetch is reexecuted on change).\n *\n * @return The fetched contract.\n */\nfunction useFetchByKey(template, keyFactory, keyDeps) {\n    return ledgerContext.useFetchByKey(template, keyFactory, keyDeps);\n}\nexports.useFetchByKey = useFetchByKey;\n/**\n * React Hook to query the ledger, the returned result is updated as the ledger state changes.\n *\n * @deprecated prefer useStreamQueries\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param queryFactory A function returning a query. If the query is omitted, all visible contracts of the given template are returned.\n * @param queryDeps The dependencies of the query (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return The matching contracts.\n */\nfunction useStreamQuery(template, queryFactory, queryDeps, closeHandler) {\n    return ledgerContext.useStreamQuery(template, queryFactory, queryDeps, closeHandler);\n}\nexports.useStreamQuery = useStreamQuery;\n/**\n * React Hook to query the ledger, the returned result is updated as the ledger state changes.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param queryFactory A function returning an array of queries. If no queryFactory is given, or if the given factory returns an empty array, all visible contracts of the given template are returned. Otherwise, returns a union of all the contracts that match at least one of the given queries.\n * @param queryDeps The dependencies of the query (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return The matching contracts.\n */\nfunction useStreamQueries(template, queryFactory, queryDeps, closeHandler) {\n    return ledgerContext.useStreamQueries(template, queryFactory, queryDeps, closeHandler);\n}\nexports.useStreamQueries = useStreamQueries;\n/**\n * React Hook to query the ledger. Same as useStreamQuery, but query by contract key instead.\n *\n * @deprecated prefer useStreamFetchByKeys\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param keyFactory A function returning a contract key. Contract\n *        keys must be in \"output\" format as defined in the [JSON API\n *        docs](https://docs.daml.com/json-api/lf-value-specification.html),\n *        i.e., have to match the types generated by the daml-types library.\n * @param keyDeps The dependencies of the fetch-by-key (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return The matching (unique) contract, or null.\n */\nfunction useStreamFetchByKey(template, keyFactory, keyDeps, closeHandler) {\n    return ledgerContext.useStreamFetchByKey(template, keyFactory, keyDeps, closeHandler);\n}\nexports.useStreamFetchByKey = useStreamFetchByKey;\n/**\n * React Hook to query the ledger. Same as useStreamQueries, but query by contract keys instead.\n *\n * @typeparam T The contract template type of the query.\n * @typeparam K The contract key type of the query.\n * @typeparam I The template id type.\n *\n * @param template The template of the contracts to match.\n * @param keyFactory A function returning an array of contract keys. Contract\n *        keys must be in \"output\" format as defined in the [JSON API\n *        docs](https://docs.daml.com/json-api/lf-value-specification.html),\n *        i.e., have to match the types generated by the daml-types library.\n * @param keyDeps The dependencies of the fetch-by-key (for which a change triggers an update of the result).\n * @param closeHandler A callback that will be called if the underlying WebSocket connection fails in an unrecoverable way.\n *\n * @return An array of the same length as the given array of keys, where each\n *         element is either the currently active contract that matches the\n *         corresponding key, or null if no active contract matches the key in\n *         the same position.\n */\nfunction useStreamFetchByKeys(template, keyFactory, keyDeps, closeHandler) {\n    return ledgerContext.useStreamFetchByKeys(template, keyFactory, keyDeps, closeHandler);\n}\nexports.useStreamFetchByKeys = useStreamFetchByKeys;\n/**\n * React Hook to reload all active queries.\n */\nfunction useReload() {\n    return ledgerContext.useReload();\n}\nexports.useReload = useReload;\n//# sourceMappingURL=defaultLedgerContext.js.map"]},"metadata":{},"sourceType":"script"}