{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WsState = exports.assert = void 0; // Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nvar types_1 = require(\"@daml/types\");\n\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\n\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\n\nvar events_1 = require(\"events\");\n\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\n\nvar lodash_1 = __importDefault(require(\"lodash\"));\n\nvar partyInfoDecoder = jtv.object({\n  identifier: jtv.string(),\n  displayName: jtv.optional(jtv.string()),\n  isLocal: jtv.boolean()\n});\n\nvar decode = function decode(decoder, data) {\n  return jtv.Result.withException(decoder.run(data));\n};\n/**\n * Decoder for a [[CreateEvent]].\n */\n\n\nvar decodeCreateEvent = function decodeCreateEvent(template) {\n  return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder,\n    signatories: types_1.List(types_1.Party).decoder,\n    observers: types_1.List(types_1.Party).decoder,\n    agreementText: types_1.Text.decoder,\n    key: template.keyDecoder,\n    payload: template.decoder\n  });\n};\n/**\n * Decoder for a [[CreateEvent]] of unknown contract template.\n */\n\n\nvar decodeCreateEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n  return decodeCreateEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[ArchiveEvent]].\n */\n\nvar decodeArchiveEvent = function decodeArchiveEvent(template) {\n  return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder\n  });\n};\n/**\n * Decoder for an [[ArchiveEvent]] of unknown contract template.\n */\n\n\nvar decodeArchiveEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n  return decodeArchiveEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[Event]].\n */\n\nvar decodeEvent = function decodeEvent(template) {\n  return jtv.oneOf(jtv.object({\n    created: decodeCreateEvent(template),\n    matchedQueries: jtv.array(jtv.number())\n  }), jtv.object({\n    created: decodeCreateEvent(template)\n  }), jtv.object({\n    archived: decodeArchiveEvent(template)\n  }));\n};\n/**\n * Decoder for an [[Event]] with unknown contract template.\n */\n\n\nvar decodeEventUnknown = jtv.oneOf(jtv.object({\n  created: decodeCreateEventUnknown,\n  matchedQueries: jtv.array(jtv.number())\n}), jtv.object({\n  created: decodeCreateEventUnknown\n}), jtv.object({\n  archived: decodeArchiveEventUnknown\n}));\n/**\n * @internal\n */\n\nfunction decodeArchiveResponse(template, archiveMethod, archiveCommand) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, _b, events;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , archiveCommand()];\n\n        case 1:\n          _a = _c.sent(), _b = _a[0], events = _a[1];\n\n          if (events.length === 1 && 'archived' in events[0] && events[0].archived.templateId === template.templateId) {\n            return [2\n            /*return*/\n            , events[0].archived];\n          } else {\n            throw Error(\"Ledger.\" + archiveMethod + \" is expected to cause one archive event for template \" + template.templateId + \"       but caused \" + JSON.stringify(events) + \".\");\n          }\n\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n/**\n * @internal\n */\n\n\nfunction isRecordWith(field, x) {\n  return typeof x === 'object' && x !== null && field in x;\n}\n/**\n *\n * @internal\n */\n\n\nfunction isCreateWithMatchedQueries(event) {\n  return isRecordWith('created', event);\n}\n/** @internal\n * exported for testing only\n */\n\n\nfunction assert(b, m) {\n  if (!b) {\n    throw m;\n  }\n}\n\nexports.assert = assert; // TODO(MH): Support comparison queries.\n\n/** @internal\n *\n * Official documentation (docs/source/json-api/search-query-language.rst)\n * currently explicitly forbids the use of lists, textmaps and genmaps in\n * queries. As long as that restriction stays, there is no need for any kind of\n * encoding here.\n */\n\nfunction encodeQuery(_template, query) {\n  return query;\n}\n/**\n * @internal\n */\n\n\nvar decodeLedgerResponse = jtv.object({\n  status: jtv.number(),\n  result: jtv.unknownJson(),\n  warnings: jtv.optional(jtv.unknownJson())\n});\n/**\n * @internal\n */\n\nvar decodeLedgerError = jtv.object({\n  status: jtv.number(),\n  errors: jtv.array(jtv.string()),\n  warnings: jtv.optional(jtv.unknownJson())\n});\n\nvar StreamEventEmitter =\n/** @class */\nfunction (_super) {\n  __extends(StreamEventEmitter, _super);\n\n  function StreamEventEmitter(_a) {\n    var beforeClosing = _a.beforeClosing;\n\n    var _this = _super.call(this) || this;\n\n    _this.beforeClosing = beforeClosing;\n    return _this;\n  }\n\n  StreamEventEmitter.prototype.close = function () {\n    this.beforeClosing();\n    this.emit('close', {\n      code: 4000,\n      reason: \"called .close()\"\n    });\n    this.removeAllListeners();\n  };\n\n  return StreamEventEmitter;\n}(events_1.EventEmitter);\n\nvar NoOffsetReceivedYet = Symbol('NoOffsetReceivedYet');\nvar NullOffsetReceived = Symbol('NullOffsetReceived');\n\nfunction append(map, key, value) {\n  var _a;\n\n  if (map.has(key)) {\n    (_a = map.get(key)) === null || _a === void 0 ? void 0 : _a.push(value);\n  } else {\n    map.set(key, [value]);\n  }\n}\n/**\n * @deprecated All usages of this function should be replaced by just\n *             iterating over the iterator. For this to happen, the TS\n *             compiler requires the --downlevelIteration flag, which\n *             however does not play nicely with Jest when running the\n *             tests.\n *\n * TODO Moving the compilation target to ES6 probably would solve this, investigate.\n */\n\n\nfunction materialize(iterator) {\n  return Array.from(iterator);\n}\n\nvar WsState;\n\n(function (WsState) {\n  WsState[WsState[\"Connecting\"] = 0] = \"Connecting\";\n  WsState[WsState[\"Open\"] = 1] = \"Open\";\n  WsState[WsState[\"Closing\"] = 2] = \"Closing\";\n  WsState[WsState[\"Closed\"] = 3] = \"Closed\";\n})(WsState = exports.WsState || (exports.WsState = {}));\n/**\n * @internal\n *\n * A special handler for stream requests to the /v1/stream/query endpoint.\n * The query endpoint supports providing offsets on a per-query basis.\n * This class leverages this feature by multiplexing virtual streaming requests to a single web socket.\n */\n\n\nvar QueryStreamsManager =\n/** @class */\nfunction () {\n  function QueryStreamsManager(_a) {\n    var token = _a.token,\n        wsBaseUrl = _a.wsBaseUrl,\n        reconnectThreshold = _a.reconnectThreshold; // Mutable state BEGIN\n    // Ongoing streaming queries that will be the downstream consumers of web socket messages\n\n    this.queries = new Set(); // Lookup tables used to route events to the relevant consumers:\n    //  - consumers for create events can be looked up based on their match index\n    //    - store the offset by which a match indexes needs to be shifted before the event is passed to the consumer\n    //  - archive events can be lookup up by template identifier\n    //    - this causes the consumer to observe what is known as \"phantom archives\", which are known and documented\n\n    this.matchIndexLookupTable = [];\n    this.templateIdsLookupTable = {}; // Accumulates each query in a flattened form to be sent as a single request to the JSON API\n\n    this.request = []; // to track changes on web socket queries\n\n    this.wsQueriesChange = false;\n    this.protocols = ['jwt.token.' + token, 'daml.ws.auth'];\n    this.url = wsBaseUrl + QueryStreamsManager.ENDPOINT;\n    this.reconnectThresholdMs = reconnectThreshold;\n  }\n\n  QueryStreamsManager.toRequest = function (query) {\n    var request = query.queries.length == 0 ? [{\n      templateIds: [query.template.templateId]\n    }] : query.queries.map(function (q) {\n      return {\n        templateIds: [query.template.templateId],\n        query: encodeQuery(query.template, q)\n      };\n    });\n\n    if (typeof query.offset === 'string') {\n      for (var _i = 0, request_1 = request; _i < request_1.length; _i++) {\n        var r = request_1[_i];\n        r.offset = query.offset;\n      }\n    }\n\n    return request;\n  };\n\n  QueryStreamsManager.prototype.resetAllState = function () {\n    // close ws if defined\n    if (this.ws !== undefined) {\n      this.ws.close();\n    }\n\n    this.queries.clear();\n    this.matchIndexLookupTable = [];\n    this.templateIdsLookupTable = {};\n    this.request = [];\n    this.ws = undefined;\n    this.wsLiveSince = undefined;\n    this.wsQueriesChange = false;\n  };\n\n  QueryStreamsManager.prototype.handleQueriesChange = function () {\n    //eslint-disable-next-line @typescript-eslint/no-this-alias\n    var manager = this; // stable self-reference for callbacks\n\n    if (manager.queries.size > 0) {\n      if (manager.ws !== undefined) {\n        //set the queries change flag to true, this should eventually get reset once the ws is closed.\n        manager.wsQueriesChange = true;\n        manager.wsLiveSince = undefined;\n        manager.ws.close();\n        manager.ws = undefined;\n      }\n\n      var ws = new isomorphic_ws_1.default(manager.url, manager.protocols); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      var onWsMessage_1 = function onWsMessage_1(ws) {\n        return function (_a) {\n          var data = _a.data;\n\n          if (ws.readyState === WsState.Open) {\n            var json = JSON.parse(data.toString());\n\n            if (isRecordWith('events', json)) {\n              var events = jtv.Result.withException(jtv.array(decodeEventUnknown).run(json.events));\n              var multiplexer = new Map();\n\n              for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n                var event_1 = events_2[_i];\n\n                if (isCreateWithMatchedQueries(event_1)) {\n                  var consumersToMatchedQueries = new Map();\n\n                  for (var _b = 0, _c = event_1.matchedQueries; _b < _c.length; _b++) {\n                    var matchIndex = _c[_b];\n                    var _d = manager.matchIndexLookupTable[matchIndex],\n                        consumer = _d[0],\n                        matchIndexOffset = _d[1];\n                    append(consumersToMatchedQueries, consumer, matchIndexOffset);\n                  }\n\n                  for (var _e = 0, _f = materialize(consumersToMatchedQueries.entries()); _e < _f.length; _e++) {\n                    var _g = _f[_e],\n                        consumer = _g[0],\n                        matchedQueries = _g[1]; // Create a new copy of the event for each consumer to freely mangle the matched queries and avoid sharing mutable state\n\n                    append(multiplexer, consumer, __assign(__assign({}, event_1), {\n                      matchedQueries: matchedQueries\n                    }));\n                  }\n                } else if ('archived' in event_1) {\n                  var consumers = manager.templateIdsLookupTable[event_1.archived.templateId];\n\n                  for (var _h = 0, _j = materialize(consumers.values()); _h < _j.length; _h++) {\n                    var consumer = _j[_h]; // Create a new copy of the event for each consumer to avoid sharing mutable state\n\n                    append(multiplexer, consumer, __assign({}, event_1));\n                  }\n                } else {\n                  console.error(event_1 + \" unknown event type received, expected created with matchedQueries or archived\", json);\n                }\n              }\n\n              for (var _k = 0, _m = materialize(multiplexer.entries()); _k < _m.length; _k++) {\n                var _o = _m[_k],\n                    consumer = _o[0],\n                    events_4 = _o[1];\n\n                for (var _p = 0, events_3 = events_4; _p < events_3.length; _p++) {\n                  var event_2 = events_3[_p];\n\n                  if (isCreateWithMatchedQueries(event_2)) {\n                    consumer.state.set(event_2.created.contractId, event_2.created);\n                  } else if ('archived' in event_2) {\n                    consumer.state.delete(event_2.archived.contractId);\n                  }\n                }\n\n                consumer.stream.emit('change', Array.from(consumer.state.values()), events_4);\n              }\n\n              if (isRecordWith('offset', json)) {\n                var offset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n\n                if (manager.wsLiveSince === undefined) {\n                  //on receiving the first offset event we consider the web socket to be live.\n                  manager.wsLiveSince = Date.now();\n                }\n\n                for (var _q = 0, _r = materialize(manager.queries.values()); _q < _r.length; _q++) {\n                  var consumer = _r[_q];\n\n                  if (!(typeof consumer.offset === 'string')) {\n                    // Rebuilding the state array from scratch to make sure mutable state is not shared between the 'change' and 'live' event\n                    consumer.stream.emit('live', Array.from(consumer.state.values()));\n                  }\n\n                  if (typeof offset === 'string') {\n                    consumer.offset = offset;\n                  } else {\n                    consumer.offset = NullOffsetReceived;\n                  }\n                }\n              }\n            } else if (isRecordWith('warnings', json)) {\n              for (var _s = 0, _u = materialize(manager.queries.values()); _s < _u.length; _s++) {\n                var query = _u[_s];\n                console.warn(query.caller + \" warnings\", json);\n              }\n            } else if (isRecordWith('errors', json)) {\n              for (var _v = 0, _w = materialize(manager.queries.values()); _v < _w.length; _v++) {\n                var query = _w[_v];\n                console.warn(query.caller + \" errors\", json);\n              }\n            } else {\n              for (var _x = 0, _y = materialize(manager.queries.values()); _x < _y.length; _x++) {\n                var query = _y[_x];\n                console.error(query.caller + \" unknown message\", json);\n              }\n            }\n          }\n        };\n      };\n\n      var onWsOpen_1 = function onWsOpen_1() {\n        var _a; // only make a new websocket request if we have registered queries\n\n\n        if (manager.queries.size > 0) {\n          var newRequests = [];\n          var newMatchIndexLookupTable = [];\n\n          for (var _i = 0, _b = materialize(manager.queries.values()); _i < _b.length; _i++) {\n            var query = _b[_i];\n            var request = QueryStreamsManager.toRequest(query); // Add entries to the lookup table for create events\n\n            var matchIndexOffset = newMatchIndexLookupTable.length;\n            var matchIndexLookupTableEntries = new Array(request.length).fill([query, matchIndexOffset]);\n            newMatchIndexLookupTable = newMatchIndexLookupTable.concat(matchIndexLookupTableEntries); // Add entries to the lookup table for archive events\n\n            for (var _c = 0, request_2 = request; _c < request_2.length; _c++) {\n              var templateIds = request_2[_c].templateIds;\n\n              for (var _d = 0, templateIds_1 = templateIds; _d < templateIds_1.length; _d++) {\n                var templateId = templateIds_1[_d];\n                manager.templateIdsLookupTable[templateId] = manager.templateIdsLookupTable[templateId] || new Set();\n                manager.templateIdsLookupTable[templateId].add(query);\n              }\n            } //since we go through all queries on the manager, we should be safely able to rebuild the whole request\n\n\n            newRequests = newRequests.concat(request);\n          }\n\n          manager.request = newRequests;\n          manager.matchIndexLookupTable = newMatchIndexLookupTable; // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n\n          (_a = manager.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(Array.from(manager.request.values())));\n        }\n      };\n\n      var onWsClose_1 = function onWsClose_1() {\n        //if not a web socket queries change then we need to initiate reconnect logic.\n        if (!manager.wsQueriesChange) {\n          // The web socket has been closed due to an error\n          // If the conditions are met, attempt to reconnect and/or inform downstream consumers\n          var now = Date.now();\n\n          if (manager.wsLiveSince !== undefined && now - manager.wsLiveSince >= manager.reconnectThresholdMs) {\n            console.log(\"Reconnecting ws, previously liveSince: \" + manager.wsLiveSince + \" and reconnectThresholdMs: \" + manager.reconnectThresholdMs);\n            manager.wsLiveSince = undefined;\n            var ws_1 = new isomorphic_ws_1.default(manager.url, manager.protocols);\n            ws_1.addEventListener('open', onWsOpen_1);\n            ws_1.addEventListener('message', onWsMessage_1(ws_1));\n            ws_1.addEventListener('close', onWsClose_1);\n            manager.ws = ws_1;\n          } else {\n            // ws has closed too quickly / never managed to connect: we give up\n            for (var _i = 0, _a = materialize(manager.queries.values()); _i < _a.length; _i++) {\n              var consumer = _a[_i];\n              consumer.stream.emit('close', {\n                code: 4001,\n                reason: 'ws connection failed'\n              });\n              consumer.stream.removeAllListeners();\n            }\n\n            manager.resetAllState();\n          }\n        } else {\n          //this was triggered due to queries change , reset the flag\n          manager.wsQueriesChange = false;\n        }\n      }; // Purposefully ignoring 'error' events; they are always followed by a 'close' event, which needs to be handled anyway\n\n\n      ws.addEventListener('open', onWsOpen_1);\n      ws.addEventListener('message', onWsMessage_1(ws));\n      ws.addEventListener('close', onWsClose_1); //eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      manager.ws = ws;\n    }\n  };\n\n  QueryStreamsManager.prototype.streamSubmit = function (template, queries, caller) {\n    //eslint-disable-next-line @typescript-eslint/no-this-alias\n    var manager = this;\n    var query = {\n      template: template,\n      queries: queries,\n      stream: new StreamEventEmitter({\n        beforeClosing: function beforeClosing() {\n          manager.queries.delete(query); // if no more queries then just let it go\n\n          if (manager.queries.size > 0) {\n            manager.handleQueriesChange();\n          }\n        }\n      }),\n      state: new Map(),\n      offset: NoOffsetReceivedYet,\n      caller: caller\n    };\n    manager.queries.add(query);\n    manager.handleQueriesChange(); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var on = function on(type, listener) {\n      var _a, _b;\n\n      if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open || ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n        query.stream.on(type, listener);\n      } else {\n        console.error(\"Trying to add a listener to a closed stream.\");\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var off = function off(type, listener) {\n      var _a, _b;\n\n      if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open || ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n        query.stream.off(type, listener);\n      } else {\n        console.error(\"Trying to remove a listener from a closed stream.\");\n      }\n    };\n\n    var close = function close() {\n      query.stream.close();\n    };\n\n    return {\n      on: on,\n      off: off,\n      close: close\n    };\n  };\n\n  QueryStreamsManager.ENDPOINT = 'v1/stream/query';\n  return QueryStreamsManager;\n}();\n/**\n * An object of type `Ledger` represents a handle to a Daml ledger.\n */\n\n\nvar Ledger =\n/** @class */\nfunction () {\n  /**\n   * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.\n   */\n  function Ledger(_a) {\n    var token = _a.token,\n        httpBaseUrl = _a.httpBaseUrl,\n        wsBaseUrl = _a.wsBaseUrl,\n        _b = _a.reconnectThreshold,\n        reconnectThreshold = _b === void 0 ? 30000 : _b,\n        _c = _a.multiplexQueryStreams,\n        multiplexQueryStreams = _c === void 0 ? true : _c;\n\n    if (!httpBaseUrl) {\n      httpBaseUrl = window.location.protocol + \"//\" + window.location.host + \"/\";\n    }\n\n    if (!(httpBaseUrl.startsWith('http://') || httpBaseUrl.startsWith('https://'))) {\n      throw Error(\"Ledger: httpBaseUrl must start with 'http://' or 'https://'. (\" + httpBaseUrl + \")\");\n    }\n\n    if (!httpBaseUrl.endsWith('/')) {\n      throw Error(\"Ledger: httpBaseUrl must end with '/'. (\" + httpBaseUrl + \")\");\n    }\n\n    if (!wsBaseUrl) {\n      wsBaseUrl = 'ws' + httpBaseUrl.slice(4);\n    }\n\n    if (!(wsBaseUrl.startsWith('ws://') || wsBaseUrl.startsWith('wss://'))) {\n      throw Error(\"Ledger: wsBaseUrl must start with 'ws://' or 'wss://'. (\" + wsBaseUrl + \")\");\n    }\n\n    if (!wsBaseUrl.endsWith('/')) {\n      throw Error(\"Ledger: wsBaseUrl must end with '/'. (\" + wsBaseUrl + \")\");\n    }\n\n    this.token = token;\n    this.httpBaseUrl = httpBaseUrl;\n    this.wsBaseUrl = wsBaseUrl;\n    this.reconnectThreshold = reconnectThreshold;\n    this.multiplexQueryStreams = multiplexQueryStreams;\n    this.queryStreamsManager = new QueryStreamsManager({\n      token: token,\n      wsBaseUrl: wsBaseUrl,\n      reconnectThreshold: reconnectThreshold\n    });\n  }\n  /**\n   * @internal\n   */\n\n\n  Ledger.prototype.auth = function () {\n    return {\n      'Authorization': 'Bearer ' + this.token\n    };\n  };\n  /**\n   * @internal\n   */\n\n\n  Ledger.prototype.throwOnError = function (r) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!r.ok) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , r.json()];\n\n          case 1:\n            json = _a.sent();\n            console.log(json);\n            throw decode(decodeLedgerError, json);\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * @internal\n   *\n   * Internal function to submit a command to the JSON API.\n   */\n\n\n  Ledger.prototype.submit = function (endpoint, payload, method) {\n    if (method === void 0) {\n      method = 'post';\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse, json, ledgerResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cross_fetch_1.default(this.httpBaseUrl + endpoint, {\n              body: JSON.stringify(payload),\n              headers: __assign(__assign({}, this.auth()), {\n                'Content-type': 'application/json'\n              }),\n              method: method\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , httpResponse.json()];\n\n          case 3:\n            json = _a.sent();\n            ledgerResponse = jtv.Result.withException(decodeLedgerResponse.run(json));\n\n            if (ledgerResponse.warnings) {\n              console.warn(ledgerResponse.warnings);\n            }\n\n            return [2\n            /*return*/\n            , ledgerResponse.result];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieve contracts for a given template.\n   *\n   * When no `query` argument is given, all contracts visible to the submitting party are returned.\n   * When a `query` argument is given, only those contracts matching the query are returned. See\n   * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n   * language.\n   *\n   * @param template The contract template of the contracts to be matched against.\n   * @param query The contract query for the contracts to be matched against.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.query = function (template, query) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = {\n              templateIds: [template.templateId],\n              query: encodeQuery(template, query)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/query', payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.array(decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a contract identified by its contract ID.\n   *\n   * @param template The template of the contract to be fetched.\n   * @param contractId The contract id of the contract to be fetched.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.fetch = function (template, contractId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            payload = {\n              templateId: template.templateId,\n              contractId: types_1.ContractId(template).encode(contractId)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/fetch', payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a contract identified by its contract key.\n   *\n   * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of\n   * its contract id.\n   *\n   * @param template The template of the contract to be fetched.\n   * @param key The contract key of the contract to be fetched.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.fetchByKey = function (template, key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (key === undefined) {\n              throw Error(\"Cannot lookup by key on template \" + template.templateId + \" because it does not define a key.\");\n            }\n\n            payload = {\n              templateId: template.templateId,\n              key: template.keyEncode(key)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/fetch', payload)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Create a contract for a given template.\n   *\n   * @param template The template of the contract to be created.\n   * @param payload The template arguments for the contract to be created.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.create = function (template, payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var command, json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            command = {\n              templateId: template.templateId,\n              payload: template.encode(payload)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/create', command)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , jtv.Result.withException(decodeCreateEvent(template).run(json))];\n        }\n      });\n    });\n  };\n  /**\n   * Exercise a choice on a contract identified by its contract ID.\n   *\n   * @param choice The choice to exercise.\n   * @param contractId The contract id of the contract to exercise.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   *\n   * @returns The return value of the choice together with a list of\n   * [[event]]'s that were created as a result of exercising the choice.\n   */\n\n\n  Ledger.prototype.exercise = function (choice, contractId, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            payload = {\n              templateId: choice.template().templateId,\n              contractId: types_1.ContractId(choice.template()).encode(contractId),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/exercise', payload)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Exercse a choice on a newly-created contract, in a single transaction.\n   *\n   * @param choice The choice to exercise.\n   * @param payload The template arguments for the newly-created contract.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   *\n   * @returns The return value of the choice together with a list of\n   * [[event]]'s that includes the creation event for the created contract as\n   * well as all the events that were created as a result of exercising the\n   * choice, including the archive event for the created contract if the choice\n   * is consuming (or otherwise archives it as part of its execution).\n   *\n   */\n\n\n  Ledger.prototype.createAndExercise = function (choice, payload, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var command, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            command = {\n              templateId: choice.template().templateId,\n              payload: choice.template().encode(payload),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/create-and-exercise', command)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Exercise a choice on a contract identified by its contract key.\n   *\n   * Same as [[exercise]], but the contract is identified by its contract key instead of its\n   * contract id.\n   *\n   * @param choice The choice to exercise.\n   * @param key The contract key of the contract to exercise.\n   * @param argument The choice arguments.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam C The type of the contract choice.\n   * @typeparam R The return type of the choice.\n   * @typeparam K The type of the contract key.\n   *\n   * @returns The return value of the choice together with a list of [[event]]'s that where created\n   * as a result of exercising the choice.\n   */\n\n\n  Ledger.prototype.exerciseByKey = function (choice, key, argument) {\n    return __awaiter(this, void 0, void 0, function () {\n      var payload, json, responseDecoder, _a, exerciseResult, events;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (key === undefined) {\n              throw Error(\"Cannot exercise by key on template \" + choice.template().templateId + \" because it does not define a key.\");\n            }\n\n            payload = {\n              templateId: choice.template().templateId,\n              key: choice.template().keyEncode(key),\n              choice: choice.choiceName,\n              argument: choice.argumentEncode(argument)\n            };\n            return [4\n            /*yield*/\n            , this.submit('v1/exercise', payload)];\n\n          case 1:\n            json = _b.sent();\n            responseDecoder = jtv.object({\n              exerciseResult: choice.resultDecoder,\n              events: jtv.array(decodeEventUnknown)\n            });\n            _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n            return [2\n            /*return*/\n            , [exerciseResult, events]];\n        }\n      });\n    });\n  };\n  /**\n   * Archive a contract identified by its contract ID.\n   *\n   * @param template The template of the contract to archive.\n   * @param contractId The contract id of the contract to archive.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.archive = function (template, contractId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , decodeArchiveResponse(template, 'archive', function () {\n          return _this.exercise(template.Archive, contractId, {});\n        })];\n      });\n    });\n  };\n  /**\n   * Archive a contract identified by its contract key.\n   * Same as [[archive]], but the contract to be archived is identified by its contract key.\n   *\n   * @param template The template of the contract to be archived.\n   * @param key The contract key of the contract to be archived.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.archiveByKey = function (template, key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , decodeArchiveResponse(template, 'archiveByKey', function () {\n          return _this.exerciseByKey(template.Archive, key, {});\n        })];\n      });\n    });\n  };\n  /**\n   * @internal\n   *\n   * Internal command to submit a request to a streaming endpoint of the\n   * JSON API. Returns a stream consisting of accumulated state together with\n   * the events that produced the latest state change. The `change` function\n   * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,\n   * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we\n   * must have the structural equalities\n   * ```\n   * change(s, []) == s\n   * change(s, x.concat(y)) == change(change(s, x), y)\n   * ```\n   * Also, `change` must never change its arguments.\n   */\n\n\n  Ledger.prototype.streamSubmit = function (callerName, template, endpoint, request, reconnectRequest, init, change) {\n    var _this = this;\n\n    var protocols = ['jwt.token.' + this.token, 'daml.ws.auth'];\n    var ws = new isomorphic_ws_1.default(this.wsBaseUrl + endpoint, protocols);\n    var isLiveSince = undefined;\n    var lastOffset = undefined;\n    var state = init;\n    var isReconnecting = false;\n    var streamClosed = false;\n    var emitter = new events_1.EventEmitter();\n\n    var onWsOpen = function onWsOpen() {\n      if (isReconnecting) {\n        // the JSON API server can't handle null offsets, even though it sends them out under\n        // special conditions when there are no transactions yet. Not sending the `offset` message\n        // will start the stream from the very beginning of the transaction log.\n        if (lastOffset !== null) ws.send(JSON.stringify({\n          'offset': lastOffset\n        }));\n        ws.send(JSON.stringify(reconnectRequest()));\n      } else {\n        ws.send(JSON.stringify(request));\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var onWsMessage = function onWsMessage(event) {\n      var json = JSON.parse(event.data.toString());\n\n      if (isRecordWith('events', json)) {\n        var events = jtv.Result.withException(jtv.array(decodeEvent(template)).run(json.events));\n\n        if (events.length > 0) {\n          state = change(state, events);\n          emitter.emit('change', state, events);\n        }\n\n        if (isRecordWith('offset', json)) {\n          lastOffset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n\n          if (isLiveSince === undefined) {\n            isLiveSince = Date.now();\n            emitter.emit('live', state);\n          }\n        }\n      } else if (isRecordWith('warnings', json)) {\n        console.warn(callerName + \" warnings\", json);\n      } else if (isRecordWith('errors', json)) {\n        console.error(callerName + \" errors\", json);\n      } else {\n        console.error(callerName + \" unknown message\", json);\n      }\n    };\n\n    var closeStream = function closeStream(status) {\n      streamClosed = true;\n      emitter.emit('close', status);\n      emitter.removeAllListeners();\n    };\n\n    var onWsClose = function onWsClose() {\n      if (streamClosed === false) {\n        var now = new Date().getTime(); // we want to try and keep the stream open, so we try to reconnect\n        // the underlying ws\n\n        if (lastOffset !== undefined && isLiveSince !== undefined && now - isLiveSince >= _this.reconnectThreshold) {\n          isLiveSince = undefined;\n          isReconnecting = true;\n          ws = new isomorphic_ws_1.default(_this.wsBaseUrl + endpoint, protocols);\n          ws.addEventListener('open', onWsOpen);\n          ws.addEventListener('message', onWsMessage);\n          ws.addEventListener('close', onWsClose);\n        } else {\n          // ws has closed too quickly / never managed to connect: we give up\n          closeStream({\n            code: 4001,\n            reason: 'ws connection failed'\n          });\n        }\n      } // no else: if the stream is closed we don't need to keep a ws\n\n    };\n\n    ws.addEventListener('open', onWsOpen);\n    ws.addEventListener('message', onWsMessage); // NOTE(MH): We ignore the 'error' event since it is always followed by a\n    // 'close' event, which we need to handle anyway.\n\n    ws.addEventListener('close', onWsClose); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    var on = function on(type, listener) {\n      if (streamClosed === false) {\n        void emitter.on(type, listener);\n      } else {\n        console.error(\"Trying to add a listener to a closed stream.\");\n      }\n    }; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var off = function off(type, listener) {\n      if (streamClosed === false) {\n        void emitter.off(type, listener);\n      } else {\n        console.error(\"Trying to remove a listener from a closed stream.\");\n      }\n    };\n\n    var close = function close() {\n      // Note: ws.close will trigger the onClose handlers of the WebSocket\n      // (here onWsClose), but they execute as a separate event after the\n      // current event in the JS event loop, i.e. in particular after the call\n      // to closeStream and thus, in this case, the onWsClose handler will see\n      // streamClosed as true.\n      ws.close();\n      closeStream({\n        code: 4000,\n        reason: \"called .close()\"\n      });\n    };\n\n    return {\n      on: on,\n      off: off,\n      close: close\n    };\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and query.\n   *\n   * The accumulated state is the current set of active contracts matching the query. When no\n   * `query` argument is given, all events visible to the submitting party are returned. When a\n   * `query` argument is given, only those create events matching the query are returned. See\n   * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n   * language.\n   *\n   * @deprecated Prefer `streamQueries`.\n   *\n   * @param template The contract template to match contracts against.\n   * @param query The query to match contracts agains.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.streamQuery = function (template, query) {\n    if (query === undefined) {\n      return this.streamQueryCommon(template, [], \"Ledger.streamQuery\");\n    } else {\n      return this.streamQueryCommon(template, [query], \"Ledger.streamQuery\");\n    }\n  };\n  /**\n   * @internal\n   *\n   */\n\n\n  Ledger.prototype.streamQueryCommon = function (template, queries, name) {\n    if (this.multiplexQueryStreams) {\n      return this.queryStreamsManager.streamSubmit(template, queries, name);\n    } else {\n      var request_3 = queries.length == 0 ? [{\n        templateIds: [template.templateId]\n      }] : queries.map(function (q) {\n        return {\n          templateIds: [template.templateId],\n          query: encodeQuery(template, q)\n        };\n      });\n\n      var reconnectRequest = function reconnectRequest() {\n        return request_3;\n      };\n\n      var change = function change(contracts, events) {\n        var archiveEvents = new Set();\n        var createEvents = [];\n\n        for (var _i = 0, events_5 = events; _i < events_5.length; _i++) {\n          var event_3 = events_5[_i];\n\n          if ('created' in event_3) {\n            createEvents.push(event_3.created);\n          } else if ('archived' in event_3) {\n            archiveEvents.add(event_3.archived.contractId);\n          }\n        }\n\n        return contracts.concat(createEvents).filter(function (contract) {\n          return !archiveEvents.has(contract.contractId);\n        });\n      };\n\n      return this.streamSubmit(name, template, 'v1/stream/query', request_3, reconnectRequest, [], change);\n    }\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and queries.\n   *\n   * If the given list is empty, the accumulated state is the set of all active\n   * contracts for the given template. Otherwise, the accumulated state is the\n   * set of all contracts that match at least one of the given queries.\n   *\n   * See https://docs.daml.com/json-api/search-query-language.html for a\n   * description of the query language.\n   *\n   * @param template The contract template to match contracts against.\n   * @param queries A query to match contracts against.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.streamQueries = function (template, queries) {\n    return this.streamQueryCommon(template, queries, \"Ledger.streamQueries\");\n  };\n  /**\n   * Retrieve a consolidated stream of events for a given template and contract key.\n   *\n   * The accumulated state is either the current active contract for the given\n   * key, or null if there is no active contract for the given key.\n   *\n   * @deprecated Prefer `streamFetchByKeys`.\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   *\n   */\n\n\n  Ledger.prototype.streamFetchByKey = function (template, key) {\n    // Note: this implementation is deliberately not unified with that of\n    // `streamFetchByKeys`, because doing so would add the requirement that the\n    // given key be in output format, whereas existing implementation supports\n    // input format.\n    var lastContractId = null;\n    var request = [{\n      templateId: template.templateId,\n      key: template.keyEncode(key)\n    }];\n\n    var reconnectRequest = function reconnectRequest() {\n      return [__assign(__assign({}, request[0]), {\n        'contractIdAtOffset': lastContractId && types_1.ContractId(template).encode(lastContractId)\n      })];\n    };\n\n    var change = function change(contract, events) {\n      for (var _i = 0, events_6 = events; _i < events_6.length; _i++) {\n        var event_4 = events_6[_i];\n\n        if ('created' in event_4) {\n          contract = event_4.created;\n        } else {\n          // i.e. 'archived' event\n          if (contract && contract.contractId === event_4.archived.contractId) {\n            contract = null;\n          }\n        }\n      }\n\n      lastContractId = contract ? contract.contractId : null;\n      return contract;\n    };\n\n    return this.streamSubmit(\"Ledger.streamFetchByKey\", template, 'v1/stream/fetch', request, reconnectRequest, null, change);\n  };\n  /**\n   * @internal\n   *\n   * Returns the same API as [[streamSubmit]] but does not, in fact, establish\n   * any socket connection. Instead, this is a stream that always has the given\n   * value as its accumulated state.\n   */\n\n\n  Ledger.prototype.constantStream = function (value) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function on(type, listener) {\n      if (type === 'live') {\n        listener(value);\n      }\n\n      if (type === 'change') {\n        listener(value, []);\n      }\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n\n\n    function off(_t, _l) {} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n    return {\n      on: on,\n      off: off,\n      close: function close() {}\n    };\n  };\n  /**\n   * Retrieve a consolidated stream of events for a list of keys and a single\n   * template.\n   *\n   * The accumulated state is an array of the same length as the given list of\n   * keys, with positional correspondence. Each element in the array represents\n   * the current contract for the given key, or is explicitly null if there is\n   * currently no active contract matching that key.\n   *\n   * Note: the given `key` objects will be compared for (deep) equality with\n   * the values returned by the API. As such, they have to be given in the\n   * \"output\" format of the API, including the values of\n   * `encodeDecimalAsString` and `encodeInt64AsString`. See [the JSON API docs\n   * for details](https://docs.daml.com/json-api/lf-value-specification.html).\n   *\n   * @typeparam T The contract template type.\n   * @typeparam K The contract key type.\n   * @typeparam I The contract id type.\n   */\n\n\n  Ledger.prototype.streamFetchByKeys = function (template, keys) {\n    // We support zero-length key so clients can more easily manage a dynamic\n    // list, without having to special-case 0-length on their side.\n    if (keys.length == 0) {\n      return this.constantStream([]);\n    }\n\n    var lastContractIds = Array(keys.length).fill(null);\n    var keysCopy = lodash_1.default.cloneDeep(keys);\n    var initState = Array(keys.length).fill(null);\n    var request = keys.map(function (k) {\n      return {\n        templateId: template.templateId,\n        key: template.keyEncode(k)\n      };\n    });\n\n    var reconnectRequest = function reconnectRequest() {\n      return request.map(function (r, idx) {\n        var lastId = lastContractIds[idx];\n        return __assign(__assign({}, r), {\n          'contractIdAtOffset': lastId && types_1.ContractId(template).encode(lastId)\n        });\n      });\n    };\n\n    var change = function change(state, events) {\n      var newState = Array.from(state);\n\n      var _loop_1 = function _loop_1(event_5) {\n        if ('created' in event_5) {\n          var k_1 = event_5.created.key;\n          keysCopy.forEach(function (requestKey, idx) {\n            if (lodash_1.default.isEqual(requestKey, k_1)) {\n              newState[idx] = event_5.created;\n            }\n          });\n        } else {\n          // i.e. 'archived' in event\n          var id_1 = event_5.archived.contractId;\n          newState.forEach(function (contract, idx) {\n            if (contract && contract.contractId === id_1) {\n              newState[idx] = null;\n            }\n          });\n        }\n      };\n\n      for (var _i = 0, events_7 = events; _i < events_7.length; _i++) {\n        var event_5 = events_7[_i];\n\n        _loop_1(event_5);\n      }\n\n      newState.forEach(function (c, idx) {\n        lastContractIds[idx] = c ? c.contractId : null;\n      });\n      return newState;\n    };\n\n    return this.streamSubmit(\"streamFetchByKeys\", template, 'v1/stream/fetch', request, reconnectRequest, initState, change);\n  };\n  /**\n   * Fetch parties by identifier.\n   *\n   * @param parties An array of Party identifiers.\n   *\n   * @returns An array of the same length, where each element corresponds to\n   * the same-index element of the given parties, ans is either a PartyInfo\n   * object if the party exists or null if it does not.\n   *\n   */\n\n\n  Ledger.prototype.getParties = function (parties) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json, resp, mapping, _i, resp_1, p, ret, idx;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (parties.length === 0) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            return [4\n            /*yield*/\n            , this.submit('v1/parties', parties)];\n\n          case 1:\n            json = _a.sent();\n            resp = decode(jtv.array(partyInfoDecoder), json);\n            mapping = {};\n\n            for (_i = 0, resp_1 = resp; _i < resp_1.length; _i++) {\n              p = resp_1[_i];\n              mapping[p.identifier] = p;\n            }\n\n            ret = Array(parties.length).fill(null);\n\n            for (idx = 0; idx < parties.length; idx++) {\n              ret[idx] = mapping[parties[idx]] || null;\n            }\n\n            return [2\n            /*return*/\n            , ret];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch all parties on the ledger.\n   *\n   * @returns All parties on the ledger, in no particular order.\n   *\n   */\n\n\n  Ledger.prototype.listKnownParties = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit('v1/parties', undefined, 'get')];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(partyInfoDecoder), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Allocate a new party.\n   *\n   * @param partyOpt Parameters for party allocation.\n   *\n   * @returns PartyInfo for the newly created party.\n   *\n   */\n\n\n  Ledger.prototype.allocateParty = function (partyOpt) {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit('v1/parties/allocate', partyOpt)];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(partyInfoDecoder, json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a list of all package IDs from the ledger.\n   *\n   * @returns List of package IDs.\n   *\n   */\n\n\n  Ledger.prototype.listPackages = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var json;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.submit('v1/packages', undefined, 'get')];\n\n          case 1:\n            json = _a.sent();\n            return [2\n            /*return*/\n            , decode(jtv.array(jtv.string()), json)];\n        }\n      });\n    });\n  };\n  /**\n   * Fetch a binary package.\n   *\n   * @returns The content of the package as a raw ArrayBuffer.\n   *\n   */\n\n\n  Ledger.prototype.getPackage = function (id) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cross_fetch_1.default(this.httpBaseUrl + 'v1/packages/' + id, {\n              headers: this.auth(),\n              method: 'get'\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , httpResponse.arrayBuffer()];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\n   * Upload a binary archive. Note that this requires admin privileges.\n   *\n   * @returns No return value on success; throws on error.\n   *\n   */\n\n\n  Ledger.prototype.uploadDarFile = function (abuf) {\n    return __awaiter(this, void 0, void 0, function () {\n      var httpResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , cross_fetch_1.default(this.httpBaseUrl + 'v1/packages', {\n              body: abuf,\n              headers: __assign(__assign({}, this.auth()), {\n                'Content-type': 'application/octet-stream'\n              }),\n              method: 'post'\n            })];\n\n          case 1:\n            httpResponse = _a.sent();\n            return [4\n            /*yield*/\n            , this.throwOnError(httpResponse)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Ledger;\n}();\n\nexports.default = Ledger;","map":{"version":3,"sources":["../../../../../../language-support/ts/daml-ledger/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WsState = exports.assert = void 0;\n// Copyright (c) 2021 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.\n// SPDX-License-Identifier: Apache-2.0\nvar types_1 = require(\"@daml/types\");\nvar jtv = __importStar(require(\"@mojotech/json-type-validation\"));\nvar cross_fetch_1 = __importDefault(require(\"cross-fetch\"));\nvar events_1 = require(\"events\");\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nvar lodash_1 = __importDefault(require(\"lodash\"));\nvar partyInfoDecoder = jtv.object({\n    identifier: jtv.string(),\n    displayName: jtv.optional(jtv.string()),\n    isLocal: jtv.boolean(),\n});\nvar decode = function (decoder, data) {\n    return jtv.Result.withException(decoder.run(data));\n};\n/**\n * Decoder for a [[CreateEvent]].\n */\nvar decodeCreateEvent = function (template) { return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder,\n    signatories: types_1.List(types_1.Party).decoder,\n    observers: types_1.List(types_1.Party).decoder,\n    agreementText: types_1.Text.decoder,\n    key: template.keyDecoder,\n    payload: template.decoder,\n}); };\n/**\n * Decoder for a [[CreateEvent]] of unknown contract template.\n */\nvar decodeCreateEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n    return decodeCreateEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[ArchiveEvent]].\n */\nvar decodeArchiveEvent = function (template) { return jtv.object({\n    templateId: jtv.constant(template.templateId),\n    contractId: types_1.ContractId(template).decoder,\n}); };\n/**\n * Decoder for an [[ArchiveEvent]] of unknown contract template.\n */\nvar decodeArchiveEventUnknown = jtv.valueAt(['templateId'], jtv.string()).andThen(function (templateId) {\n    return decodeArchiveEvent(types_1.lookupTemplate(templateId));\n});\n/**\n * Decoder for an [[Event]].\n */\nvar decodeEvent = function (template) { return jtv.oneOf(jtv.object({ created: decodeCreateEvent(template), matchedQueries: jtv.array(jtv.number()) }), jtv.object({ created: decodeCreateEvent(template) }), jtv.object({ archived: decodeArchiveEvent(template) })); };\n/**\n * Decoder for an [[Event]] with unknown contract template.\n */\nvar decodeEventUnknown = jtv.oneOf(jtv.object({ created: decodeCreateEventUnknown, matchedQueries: jtv.array(jtv.number()) }), jtv.object({ created: decodeCreateEventUnknown }), jtv.object({ archived: decodeArchiveEventUnknown }));\n/**\n * @internal\n */\nfunction decodeArchiveResponse(template, archiveMethod, archiveCommand) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, _b, events;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0: return [4 /*yield*/, archiveCommand()];\n                case 1:\n                    _a = _c.sent(), _b = _a[0], events = _a[1];\n                    if (events.length === 1 && 'archived' in events[0] && events[0].archived.templateId === template.templateId) {\n                        return [2 /*return*/, events[0].archived];\n                    }\n                    else {\n                        throw Error(\"Ledger.\" + archiveMethod + \" is expected to cause one archive event for template \" + template.templateId + \"       but caused \" + JSON.stringify(events) + \".\");\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * @internal\n */\nfunction isRecordWith(field, x) {\n    return typeof x === 'object' && x !== null && field in x;\n}\n/**\n *\n * @internal\n */\nfunction isCreateWithMatchedQueries(event) {\n    return isRecordWith('created', event);\n}\n/** @internal\n * exported for testing only\n */\nfunction assert(b, m) {\n    if (!b) {\n        throw m;\n    }\n}\nexports.assert = assert;\n// TODO(MH): Support comparison queries.\n/** @internal\n *\n * Official documentation (docs/source/json-api/search-query-language.rst)\n * currently explicitly forbids the use of lists, textmaps and genmaps in\n * queries. As long as that restriction stays, there is no need for any kind of\n * encoding here.\n */\nfunction encodeQuery(_template, query) {\n    return query;\n}\n/**\n * @internal\n */\nvar decodeLedgerResponse = jtv.object({\n    status: jtv.number(),\n    result: jtv.unknownJson(),\n    warnings: jtv.optional(jtv.unknownJson()),\n});\n/**\n * @internal\n */\nvar decodeLedgerError = jtv.object({\n    status: jtv.number(),\n    errors: jtv.array(jtv.string()),\n    warnings: jtv.optional(jtv.unknownJson()),\n});\nvar StreamEventEmitter = /** @class */ (function (_super) {\n    __extends(StreamEventEmitter, _super);\n    function StreamEventEmitter(_a) {\n        var beforeClosing = _a.beforeClosing;\n        var _this = _super.call(this) || this;\n        _this.beforeClosing = beforeClosing;\n        return _this;\n    }\n    StreamEventEmitter.prototype.close = function () {\n        this.beforeClosing();\n        this.emit('close', { code: 4000, reason: \"called .close()\" });\n        this.removeAllListeners();\n    };\n    return StreamEventEmitter;\n}(events_1.EventEmitter));\nvar NoOffsetReceivedYet = Symbol('NoOffsetReceivedYet');\nvar NullOffsetReceived = Symbol('NullOffsetReceived');\nfunction append(map, key, value) {\n    var _a;\n    if (map.has(key)) {\n        (_a = map.get(key)) === null || _a === void 0 ? void 0 : _a.push(value);\n    }\n    else {\n        map.set(key, [value]);\n    }\n}\n/**\n * @deprecated All usages of this function should be replaced by just\n *             iterating over the iterator. For this to happen, the TS\n *             compiler requires the --downlevelIteration flag, which\n *             however does not play nicely with Jest when running the\n *             tests.\n *\n * TODO Moving the compilation target to ES6 probably would solve this, investigate.\n */\nfunction materialize(iterator) {\n    return Array.from(iterator);\n}\nvar WsState;\n(function (WsState) {\n    WsState[WsState[\"Connecting\"] = 0] = \"Connecting\";\n    WsState[WsState[\"Open\"] = 1] = \"Open\";\n    WsState[WsState[\"Closing\"] = 2] = \"Closing\";\n    WsState[WsState[\"Closed\"] = 3] = \"Closed\";\n})(WsState = exports.WsState || (exports.WsState = {}));\n/**\n * @internal\n *\n * A special handler for stream requests to the /v1/stream/query endpoint.\n * The query endpoint supports providing offsets on a per-query basis.\n * This class leverages this feature by multiplexing virtual streaming requests to a single web socket.\n */\nvar QueryStreamsManager = /** @class */ (function () {\n    function QueryStreamsManager(_a) {\n        var token = _a.token, wsBaseUrl = _a.wsBaseUrl, reconnectThreshold = _a.reconnectThreshold;\n        // Mutable state BEGIN\n        // Ongoing streaming queries that will be the downstream consumers of web socket messages\n        this.queries = new Set();\n        // Lookup tables used to route events to the relevant consumers:\n        //  - consumers for create events can be looked up based on their match index\n        //    - store the offset by which a match indexes needs to be shifted before the event is passed to the consumer\n        //  - archive events can be lookup up by template identifier\n        //    - this causes the consumer to observe what is known as \"phantom archives\", which are known and documented\n        this.matchIndexLookupTable = [];\n        this.templateIdsLookupTable = {};\n        // Accumulates each query in a flattened form to be sent as a single request to the JSON API\n        this.request = [];\n        // to track changes on web socket queries\n        this.wsQueriesChange = false;\n        this.protocols = ['jwt.token.' + token, 'daml.ws.auth'];\n        this.url = wsBaseUrl + QueryStreamsManager.ENDPOINT;\n        this.reconnectThresholdMs = reconnectThreshold;\n    }\n    QueryStreamsManager.toRequest = function (query) {\n        var request = query.queries.length == 0 ?\n            [{ templateIds: [query.template.templateId] }]\n            : query.queries.map(function (q) { return ({ templateIds: [query.template.templateId], query: encodeQuery(query.template, q) }); });\n        if (typeof query.offset === 'string') {\n            for (var _i = 0, request_1 = request; _i < request_1.length; _i++) {\n                var r = request_1[_i];\n                r.offset = query.offset;\n            }\n        }\n        return request;\n    };\n    QueryStreamsManager.prototype.resetAllState = function () {\n        // close ws if defined\n        if (this.ws !== undefined) {\n            this.ws.close();\n        }\n        this.queries.clear();\n        this.matchIndexLookupTable = [];\n        this.templateIdsLookupTable = {};\n        this.request = [];\n        this.ws = undefined;\n        this.wsLiveSince = undefined;\n        this.wsQueriesChange = false;\n    };\n    QueryStreamsManager.prototype.handleQueriesChange = function () {\n        //eslint-disable-next-line @typescript-eslint/no-this-alias\n        var manager = this; // stable self-reference for callbacks\n        if (manager.queries.size > 0) {\n            if (manager.ws !== undefined) {\n                //set the queries change flag to true, this should eventually get reset once the ws is closed.\n                manager.wsQueriesChange = true;\n                manager.wsLiveSince = undefined;\n                manager.ws.close();\n                manager.ws = undefined;\n            }\n            var ws = new isomorphic_ws_1.default(manager.url, manager.protocols);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            var onWsMessage_1 = function (ws) { return function (_a) {\n                var data = _a.data;\n                if (ws.readyState === WsState.Open) {\n                    var json = JSON.parse(data.toString());\n                    if (isRecordWith('events', json)) {\n                        var events = jtv.Result.withException(jtv.array(decodeEventUnknown).run(json.events));\n                        var multiplexer = new Map();\n                        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n                            var event_1 = events_2[_i];\n                            if (isCreateWithMatchedQueries(event_1)) {\n                                var consumersToMatchedQueries = new Map();\n                                for (var _b = 0, _c = event_1.matchedQueries; _b < _c.length; _b++) {\n                                    var matchIndex = _c[_b];\n                                    var _d = manager.matchIndexLookupTable[matchIndex], consumer = _d[0], matchIndexOffset = _d[1];\n                                    append(consumersToMatchedQueries, consumer, matchIndexOffset);\n                                }\n                                for (var _e = 0, _f = materialize(consumersToMatchedQueries.entries()); _e < _f.length; _e++) {\n                                    var _g = _f[_e], consumer = _g[0], matchedQueries = _g[1];\n                                    // Create a new copy of the event for each consumer to freely mangle the matched queries and avoid sharing mutable state\n                                    append(multiplexer, consumer, __assign(__assign({}, event_1), { matchedQueries: matchedQueries }));\n                                }\n                            }\n                            else if ('archived' in event_1) {\n                                var consumers = manager.templateIdsLookupTable[event_1.archived.templateId];\n                                for (var _h = 0, _j = materialize(consumers.values()); _h < _j.length; _h++) {\n                                    var consumer = _j[_h];\n                                    // Create a new copy of the event for each consumer to avoid sharing mutable state\n                                    append(multiplexer, consumer, __assign({}, event_1));\n                                }\n                            }\n                            else {\n                                console.error(event_1 + \" unknown event type received, expected created with matchedQueries or archived\", json);\n                            }\n                        }\n                        for (var _k = 0, _m = materialize(multiplexer.entries()); _k < _m.length; _k++) {\n                            var _o = _m[_k], consumer = _o[0], events_4 = _o[1];\n                            for (var _p = 0, events_3 = events_4; _p < events_3.length; _p++) {\n                                var event_2 = events_3[_p];\n                                if (isCreateWithMatchedQueries(event_2)) {\n                                    consumer.state.set(event_2.created.contractId, event_2.created);\n                                }\n                                else if ('archived' in event_2) {\n                                    consumer.state.delete(event_2.archived.contractId);\n                                }\n                            }\n                            consumer.stream.emit('change', Array.from(consumer.state.values()), events_4);\n                        }\n                        if (isRecordWith('offset', json)) {\n                            var offset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n                            if (manager.wsLiveSince === undefined) {\n                                //on receiving the first offset event we consider the web socket to be live.\n                                manager.wsLiveSince = Date.now();\n                            }\n                            for (var _q = 0, _r = materialize(manager.queries.values()); _q < _r.length; _q++) {\n                                var consumer = _r[_q];\n                                if (!(typeof consumer.offset === 'string')) {\n                                    // Rebuilding the state array from scratch to make sure mutable state is not shared between the 'change' and 'live' event\n                                    consumer.stream.emit('live', Array.from(consumer.state.values()));\n                                }\n                                if (typeof offset === 'string') {\n                                    consumer.offset = offset;\n                                }\n                                else {\n                                    consumer.offset = NullOffsetReceived;\n                                }\n                            }\n                        }\n                    }\n                    else if (isRecordWith('warnings', json)) {\n                        for (var _s = 0, _u = materialize(manager.queries.values()); _s < _u.length; _s++) {\n                            var query = _u[_s];\n                            console.warn(query.caller + \" warnings\", json);\n                        }\n                    }\n                    else if (isRecordWith('errors', json)) {\n                        for (var _v = 0, _w = materialize(manager.queries.values()); _v < _w.length; _v++) {\n                            var query = _w[_v];\n                            console.warn(query.caller + \" errors\", json);\n                        }\n                    }\n                    else {\n                        for (var _x = 0, _y = materialize(manager.queries.values()); _x < _y.length; _x++) {\n                            var query = _y[_x];\n                            console.error(query.caller + \" unknown message\", json);\n                        }\n                    }\n                }\n            }; };\n            var onWsOpen_1 = function () {\n                var _a;\n                // only make a new websocket request if we have registered queries\n                if (manager.queries.size > 0) {\n                    var newRequests = [];\n                    var newMatchIndexLookupTable = [];\n                    for (var _i = 0, _b = materialize(manager.queries.values()); _i < _b.length; _i++) {\n                        var query = _b[_i];\n                        var request = QueryStreamsManager.toRequest(query);\n                        // Add entries to the lookup table for create events\n                        var matchIndexOffset = newMatchIndexLookupTable.length;\n                        var matchIndexLookupTableEntries = new Array(request.length).fill([query, matchIndexOffset]);\n                        newMatchIndexLookupTable = newMatchIndexLookupTable.concat(matchIndexLookupTableEntries);\n                        // Add entries to the lookup table for archive events\n                        for (var _c = 0, request_2 = request; _c < request_2.length; _c++) {\n                            var templateIds = request_2[_c].templateIds;\n                            for (var _d = 0, templateIds_1 = templateIds; _d < templateIds_1.length; _d++) {\n                                var templateId = templateIds_1[_d];\n                                manager.templateIdsLookupTable[templateId] = manager.templateIdsLookupTable[templateId] || new Set();\n                                manager.templateIdsLookupTable[templateId].add(query);\n                            }\n                        }\n                        //since we go through all queries on the manager, we should be safely able to rebuild the whole request\n                        newRequests = newRequests.concat(request);\n                    }\n                    manager.request = newRequests;\n                    manager.matchIndexLookupTable = newMatchIndexLookupTable;\n                    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n                    (_a = manager.ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(Array.from(manager.request.values())));\n                }\n            };\n            var onWsClose_1 = function () {\n                //if not a web socket queries change then we need to initiate reconnect logic.\n                if (!manager.wsQueriesChange) {\n                    // The web socket has been closed due to an error\n                    // If the conditions are met, attempt to reconnect and/or inform downstream consumers\n                    var now = Date.now();\n                    if (manager.wsLiveSince !== undefined && now - manager.wsLiveSince >= manager.reconnectThresholdMs) {\n                        console.log(\"Reconnecting ws, previously liveSince: \" + manager.wsLiveSince + \" and reconnectThresholdMs: \" + manager.reconnectThresholdMs);\n                        manager.wsLiveSince = undefined;\n                        var ws_1 = new isomorphic_ws_1.default(manager.url, manager.protocols);\n                        ws_1.addEventListener('open', onWsOpen_1);\n                        ws_1.addEventListener('message', onWsMessage_1(ws_1));\n                        ws_1.addEventListener('close', onWsClose_1);\n                        manager.ws = ws_1;\n                    }\n                    else {\n                        // ws has closed too quickly / never managed to connect: we give up\n                        for (var _i = 0, _a = materialize(manager.queries.values()); _i < _a.length; _i++) {\n                            var consumer = _a[_i];\n                            consumer.stream.emit('close', { code: 4001, reason: 'ws connection failed' });\n                            consumer.stream.removeAllListeners();\n                        }\n                        manager.resetAllState();\n                    }\n                }\n                else {\n                    //this was triggered due to queries change , reset the flag\n                    manager.wsQueriesChange = false;\n                }\n            };\n            // Purposefully ignoring 'error' events; they are always followed by a 'close' event, which needs to be handled anyway\n            ws.addEventListener('open', onWsOpen_1);\n            ws.addEventListener('message', onWsMessage_1(ws));\n            ws.addEventListener('close', onWsClose_1);\n            //eslint-disable-next-line @typescript-eslint/no-this-alias\n            manager.ws = ws;\n        }\n    };\n    QueryStreamsManager.prototype.streamSubmit = function (template, queries, caller) {\n        //eslint-disable-next-line @typescript-eslint/no-this-alias\n        var manager = this;\n        var query = {\n            template: template,\n            queries: queries,\n            stream: new StreamEventEmitter({\n                beforeClosing: function () {\n                    manager.queries.delete(query);\n                    // if no more queries then just let it go\n                    if (manager.queries.size > 0) {\n                        manager.handleQueriesChange();\n                    }\n                }\n            }),\n            state: new Map(),\n            offset: NoOffsetReceivedYet,\n            caller: caller,\n        };\n        manager.queries.add(query);\n        manager.handleQueriesChange();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var on = function (type, listener) {\n            var _a, _b;\n            if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open || ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n                query.stream.on(type, listener);\n            }\n            else {\n                console.error(\"Trying to add a listener to a closed stream.\");\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var off = function (type, listener) {\n            var _a, _b;\n            if (((_a = manager.ws) === null || _a === void 0 ? void 0 : _a.readyState) === WsState.Open || ((_b = manager.ws) === null || _b === void 0 ? void 0 : _b.readyState) === WsState.Connecting) {\n                query.stream.off(type, listener);\n            }\n            else {\n                console.error(\"Trying to remove a listener from a closed stream.\");\n            }\n        };\n        var close = function () {\n            query.stream.close();\n        };\n        return { on: on, off: off, close: close };\n    };\n    QueryStreamsManager.ENDPOINT = 'v1/stream/query';\n    return QueryStreamsManager;\n}());\n/**\n * An object of type `Ledger` represents a handle to a Daml ledger.\n */\nvar Ledger = /** @class */ (function () {\n    /**\n     * Construct a new `Ledger` object. See [[LedgerOptions]] for the constructor arguments.\n     */\n    function Ledger(_a) {\n        var token = _a.token, httpBaseUrl = _a.httpBaseUrl, wsBaseUrl = _a.wsBaseUrl, _b = _a.reconnectThreshold, reconnectThreshold = _b === void 0 ? 30000 : _b, _c = _a.multiplexQueryStreams, multiplexQueryStreams = _c === void 0 ? true : _c;\n        if (!httpBaseUrl) {\n            httpBaseUrl = window.location.protocol + \"//\" + window.location.host + \"/\";\n        }\n        if (!(httpBaseUrl.startsWith('http://') || httpBaseUrl.startsWith('https://'))) {\n            throw Error(\"Ledger: httpBaseUrl must start with 'http://' or 'https://'. (\" + httpBaseUrl + \")\");\n        }\n        if (!httpBaseUrl.endsWith('/')) {\n            throw Error(\"Ledger: httpBaseUrl must end with '/'. (\" + httpBaseUrl + \")\");\n        }\n        if (!wsBaseUrl) {\n            wsBaseUrl = 'ws' + httpBaseUrl.slice(4);\n        }\n        if (!(wsBaseUrl.startsWith('ws://') || wsBaseUrl.startsWith('wss://'))) {\n            throw Error(\"Ledger: wsBaseUrl must start with 'ws://' or 'wss://'. (\" + wsBaseUrl + \")\");\n        }\n        if (!wsBaseUrl.endsWith('/')) {\n            throw Error(\"Ledger: wsBaseUrl must end with '/'. (\" + wsBaseUrl + \")\");\n        }\n        this.token = token;\n        this.httpBaseUrl = httpBaseUrl;\n        this.wsBaseUrl = wsBaseUrl;\n        this.reconnectThreshold = reconnectThreshold;\n        this.multiplexQueryStreams = multiplexQueryStreams;\n        this.queryStreamsManager = new QueryStreamsManager({ token: token, wsBaseUrl: wsBaseUrl, reconnectThreshold: reconnectThreshold });\n    }\n    /**\n     * @internal\n     */\n    Ledger.prototype.auth = function () {\n        return { 'Authorization': 'Bearer ' + this.token };\n    };\n    /**\n     * @internal\n     */\n    Ledger.prototype.throwOnError = function (r) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!r.ok) return [3 /*break*/, 2];\n                        return [4 /*yield*/, r.json()];\n                    case 1:\n                        json = _a.sent();\n                        console.log(json);\n                        throw decode(decodeLedgerError, json);\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * @internal\n     *\n     * Internal function to submit a command to the JSON API.\n     */\n    Ledger.prototype.submit = function (endpoint, payload, method) {\n        if (method === void 0) { method = 'post'; }\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse, json, ledgerResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cross_fetch_1.default(this.httpBaseUrl + endpoint, {\n                            body: JSON.stringify(payload),\n                            headers: __assign(__assign({}, this.auth()), { 'Content-type': 'application/json' }),\n                            method: method,\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, httpResponse.json()];\n                    case 3:\n                        json = _a.sent();\n                        ledgerResponse = jtv.Result.withException(decodeLedgerResponse.run(json));\n                        if (ledgerResponse.warnings) {\n                            console.warn(ledgerResponse.warnings);\n                        }\n                        return [2 /*return*/, ledgerResponse.result];\n                }\n            });\n        });\n    };\n    /**\n     * Retrieve contracts for a given template.\n     *\n     * When no `query` argument is given, all contracts visible to the submitting party are returned.\n     * When a `query` argument is given, only those contracts matching the query are returned. See\n     * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n     * language.\n     *\n     * @param template The contract template of the contracts to be matched against.\n     * @param query The contract query for the contracts to be matched against.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.query = function (template, query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = { templateIds: [template.templateId], query: encodeQuery(template, query) };\n                        return [4 /*yield*/, this.submit('v1/query', payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.array(decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a contract identified by its contract ID.\n     *\n     * @param template The template of the contract to be fetched.\n     * @param contractId The contract id of the contract to be fetched.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.fetch = function (template, contractId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        payload = {\n                            templateId: template.templateId,\n                            contractId: types_1.ContractId(template).encode(contractId),\n                        };\n                        return [4 /*yield*/, this.submit('v1/fetch', payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a contract identified by its contract key.\n     *\n     * Same as [[fetch]], but the contract to be fetched is identified by its contract key instead of\n     * its contract id.\n     *\n     * @param template The template of the contract to be fetched.\n     * @param key The contract key of the contract to be fetched.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.fetchByKey = function (template, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (key === undefined) {\n                            throw Error(\"Cannot lookup by key on template \" + template.templateId + \" because it does not define a key.\");\n                        }\n                        payload = {\n                            templateId: template.templateId,\n                            key: template.keyEncode(key),\n                        };\n                        return [4 /*yield*/, this.submit('v1/fetch', payload)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(jtv.oneOf(jtv.constant(null), decodeCreateEvent(template)).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Create a contract for a given template.\n     *\n     * @param template The template of the contract to be created.\n     * @param payload The template arguments for the contract to be created.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.create = function (template, payload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var command, json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        command = {\n                            templateId: template.templateId,\n                            payload: template.encode(payload),\n                        };\n                        return [4 /*yield*/, this.submit('v1/create', command)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, jtv.Result.withException(decodeCreateEvent(template).run(json))];\n                }\n            });\n        });\n    };\n    /**\n     * Exercise a choice on a contract identified by its contract ID.\n     *\n     * @param choice The choice to exercise.\n     * @param contractId The contract id of the contract to exercise.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     *\n     * @returns The return value of the choice together with a list of\n     * [[event]]'s that were created as a result of exercising the choice.\n     */\n    Ledger.prototype.exercise = function (choice, contractId, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        payload = {\n                            templateId: choice.template().templateId,\n                            contractId: types_1.ContractId(choice.template()).encode(contractId),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit('v1/exercise', payload)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Exercse a choice on a newly-created contract, in a single transaction.\n     *\n     * @param choice The choice to exercise.\n     * @param payload The template arguments for the newly-created contract.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     *\n     * @returns The return value of the choice together with a list of\n     * [[event]]'s that includes the creation event for the created contract as\n     * well as all the events that were created as a result of exercising the\n     * choice, including the archive event for the created contract if the choice\n     * is consuming (or otherwise archives it as part of its execution).\n     *\n     */\n    Ledger.prototype.createAndExercise = function (choice, payload, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var command, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        command = {\n                            templateId: choice.template().templateId,\n                            payload: choice.template().encode(payload),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit('v1/create-and-exercise', command)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Exercise a choice on a contract identified by its contract key.\n     *\n     * Same as [[exercise]], but the contract is identified by its contract key instead of its\n     * contract id.\n     *\n     * @param choice The choice to exercise.\n     * @param key The contract key of the contract to exercise.\n     * @param argument The choice arguments.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam C The type of the contract choice.\n     * @typeparam R The return type of the choice.\n     * @typeparam K The type of the contract key.\n     *\n     * @returns The return value of the choice together with a list of [[event]]'s that where created\n     * as a result of exercising the choice.\n     */\n    Ledger.prototype.exerciseByKey = function (choice, key, argument) {\n        return __awaiter(this, void 0, void 0, function () {\n            var payload, json, responseDecoder, _a, exerciseResult, events;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (key === undefined) {\n                            throw Error(\"Cannot exercise by key on template \" + choice.template().templateId + \" because it does not define a key.\");\n                        }\n                        payload = {\n                            templateId: choice.template().templateId,\n                            key: choice.template().keyEncode(key),\n                            choice: choice.choiceName,\n                            argument: choice.argumentEncode(argument),\n                        };\n                        return [4 /*yield*/, this.submit('v1/exercise', payload)];\n                    case 1:\n                        json = _b.sent();\n                        responseDecoder = jtv.object({\n                            exerciseResult: choice.resultDecoder,\n                            events: jtv.array(decodeEventUnknown),\n                        });\n                        _a = jtv.Result.withException(responseDecoder.run(json)), exerciseResult = _a.exerciseResult, events = _a.events;\n                        return [2 /*return*/, [exerciseResult, events]];\n                }\n            });\n        });\n    };\n    /**\n     * Archive a contract identified by its contract ID.\n     *\n     * @param template The template of the contract to archive.\n     * @param contractId The contract id of the contract to archive.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.archive = function (template, contractId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, decodeArchiveResponse(template, 'archive', function () { return _this.exercise(template.Archive, contractId, {}); })];\n            });\n        });\n    };\n    /**\n     * Archive a contract identified by its contract key.\n     * Same as [[archive]], but the contract to be archived is identified by its contract key.\n     *\n     * @param template The template of the contract to be archived.\n     * @param key The contract key of the contract to be archived.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.archiveByKey = function (template, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, decodeArchiveResponse(template, 'archiveByKey', function () { return _this.exerciseByKey(template.Archive, key, {}); })];\n            });\n        });\n    };\n    /**\n     * @internal\n     *\n     * Internal command to submit a request to a streaming endpoint of the\n     * JSON API. Returns a stream consisting of accumulated state together with\n     * the events that produced the latest state change. The `change` function\n     * must be an operation of the monoid `Event<T, K, I>[]` on the set `State`,\n     * i.e., for all `s: State` and `x, y: Event<T, K, I>[]` we\n     * must have the structural equalities\n     * ```\n     * change(s, []) == s\n     * change(s, x.concat(y)) == change(change(s, x), y)\n     * ```\n     * Also, `change` must never change its arguments.\n     */\n    Ledger.prototype.streamSubmit = function (callerName, template, endpoint, request, reconnectRequest, init, change) {\n        var _this = this;\n        var protocols = ['jwt.token.' + this.token, 'daml.ws.auth'];\n        var ws = new isomorphic_ws_1.default(this.wsBaseUrl + endpoint, protocols);\n        var isLiveSince = undefined;\n        var lastOffset = undefined;\n        var state = init;\n        var isReconnecting = false;\n        var streamClosed = false;\n        var emitter = new events_1.EventEmitter();\n        var onWsOpen = function () {\n            if (isReconnecting) {\n                // the JSON API server can't handle null offsets, even though it sends them out under\n                // special conditions when there are no transactions yet. Not sending the `offset` message\n                // will start the stream from the very beginning of the transaction log.\n                if (lastOffset !== null)\n                    ws.send(JSON.stringify({ 'offset': lastOffset }));\n                ws.send(JSON.stringify(reconnectRequest()));\n            }\n            else {\n                ws.send(JSON.stringify(request));\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var onWsMessage = function (event) {\n            var json = JSON.parse(event.data.toString());\n            if (isRecordWith('events', json)) {\n                var events = jtv.Result.withException(jtv.array(decodeEvent(template)).run(json.events));\n                if (events.length > 0) {\n                    state = change(state, events);\n                    emitter.emit('change', state, events);\n                }\n                if (isRecordWith('offset', json)) {\n                    lastOffset = jtv.Result.withException(jtv.oneOf(jtv.constant(null), jtv.string()).run(json.offset));\n                    if (isLiveSince === undefined) {\n                        isLiveSince = Date.now();\n                        emitter.emit('live', state);\n                    }\n                }\n            }\n            else if (isRecordWith('warnings', json)) {\n                console.warn(callerName + \" warnings\", json);\n            }\n            else if (isRecordWith('errors', json)) {\n                console.error(callerName + \" errors\", json);\n            }\n            else {\n                console.error(callerName + \" unknown message\", json);\n            }\n        };\n        var closeStream = function (status) {\n            streamClosed = true;\n            emitter.emit('close', status);\n            emitter.removeAllListeners();\n        };\n        var onWsClose = function () {\n            if (streamClosed === false) {\n                var now = new Date().getTime();\n                // we want to try and keep the stream open, so we try to reconnect\n                // the underlying ws\n                if (lastOffset !== undefined && isLiveSince !== undefined && now - isLiveSince >= _this.reconnectThreshold) {\n                    isLiveSince = undefined;\n                    isReconnecting = true;\n                    ws = new isomorphic_ws_1.default(_this.wsBaseUrl + endpoint, protocols);\n                    ws.addEventListener('open', onWsOpen);\n                    ws.addEventListener('message', onWsMessage);\n                    ws.addEventListener('close', onWsClose);\n                }\n                else {\n                    // ws has closed too quickly / never managed to connect: we give up\n                    closeStream({ code: 4001, reason: 'ws connection failed' });\n                }\n            } // no else: if the stream is closed we don't need to keep a ws\n        };\n        ws.addEventListener('open', onWsOpen);\n        ws.addEventListener('message', onWsMessage);\n        // NOTE(MH): We ignore the 'error' event since it is always followed by a\n        // 'close' event, which we need to handle anyway.\n        ws.addEventListener('close', onWsClose);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var on = function (type, listener) {\n            if (streamClosed === false) {\n                void emitter.on(type, listener);\n            }\n            else {\n                console.error(\"Trying to add a listener to a closed stream.\");\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var off = function (type, listener) {\n            if (streamClosed === false) {\n                void emitter.off(type, listener);\n            }\n            else {\n                console.error(\"Trying to remove a listener from a closed stream.\");\n            }\n        };\n        var close = function () {\n            // Note: ws.close will trigger the onClose handlers of the WebSocket\n            // (here onWsClose), but they execute as a separate event after the\n            // current event in the JS event loop, i.e. in particular after the call\n            // to closeStream and thus, in this case, the onWsClose handler will see\n            // streamClosed as true.\n            ws.close();\n            closeStream({ code: 4000, reason: \"called .close()\" });\n        };\n        return { on: on, off: off, close: close };\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and query.\n     *\n     * The accumulated state is the current set of active contracts matching the query. When no\n     * `query` argument is given, all events visible to the submitting party are returned. When a\n     * `query` argument is given, only those create events matching the query are returned. See\n     * https://docs.daml.com/json-api/search-query-language.html for a description of the query\n     * language.\n     *\n     * @deprecated Prefer `streamQueries`.\n     *\n     * @param template The contract template to match contracts against.\n     * @param query The query to match contracts agains.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.streamQuery = function (template, query) {\n        if (query === undefined) {\n            return this.streamQueryCommon(template, [], \"Ledger.streamQuery\");\n        }\n        else {\n            return this.streamQueryCommon(template, [query], \"Ledger.streamQuery\");\n        }\n    };\n    /**\n     * @internal\n     *\n     */\n    Ledger.prototype.streamQueryCommon = function (template, queries, name) {\n        if (this.multiplexQueryStreams) {\n            return this.queryStreamsManager.streamSubmit(template, queries, name);\n        }\n        else {\n            var request_3 = queries.length == 0 ?\n                [{ templateIds: [template.templateId] }]\n                : queries.map(function (q) { return ({ templateIds: [template.templateId], query: encodeQuery(template, q) }); });\n            var reconnectRequest = function () { return request_3; };\n            var change = function (contracts, events) {\n                var archiveEvents = new Set();\n                var createEvents = [];\n                for (var _i = 0, events_5 = events; _i < events_5.length; _i++) {\n                    var event_3 = events_5[_i];\n                    if ('created' in event_3) {\n                        createEvents.push(event_3.created);\n                    }\n                    else if ('archived' in event_3) {\n                        archiveEvents.add(event_3.archived.contractId);\n                    }\n                }\n                return contracts\n                    .concat(createEvents)\n                    .filter(function (contract) { return !archiveEvents.has(contract.contractId); });\n            };\n            return this.streamSubmit(name, template, 'v1/stream/query', request_3, reconnectRequest, [], change);\n        }\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and queries.\n     *\n     * If the given list is empty, the accumulated state is the set of all active\n     * contracts for the given template. Otherwise, the accumulated state is the\n     * set of all contracts that match at least one of the given queries.\n     *\n     * See https://docs.daml.com/json-api/search-query-language.html for a\n     * description of the query language.\n     *\n     * @param template The contract template to match contracts against.\n     * @param queries A query to match contracts against.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.streamQueries = function (template, queries) {\n        return this.streamQueryCommon(template, queries, \"Ledger.streamQueries\");\n    };\n    /**\n     * Retrieve a consolidated stream of events for a given template and contract key.\n     *\n     * The accumulated state is either the current active contract for the given\n     * key, or null if there is no active contract for the given key.\n     *\n     * @deprecated Prefer `streamFetchByKeys`.\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     *\n     */\n    Ledger.prototype.streamFetchByKey = function (template, key) {\n        // Note: this implementation is deliberately not unified with that of\n        // `streamFetchByKeys`, because doing so would add the requirement that the\n        // given key be in output format, whereas existing implementation supports\n        // input format.\n        var lastContractId = null;\n        var request = [{ templateId: template.templateId, key: template.keyEncode(key) }];\n        var reconnectRequest = function () { return [__assign(__assign({}, request[0]), { 'contractIdAtOffset': lastContractId && types_1.ContractId(template).encode(lastContractId) })]; };\n        var change = function (contract, events) {\n            for (var _i = 0, events_6 = events; _i < events_6.length; _i++) {\n                var event_4 = events_6[_i];\n                if ('created' in event_4) {\n                    contract = event_4.created;\n                }\n                else { // i.e. 'archived' event\n                    if (contract && contract.contractId === event_4.archived.contractId) {\n                        contract = null;\n                    }\n                }\n            }\n            lastContractId = contract ? contract.contractId : null;\n            return contract;\n        };\n        return this.streamSubmit(\"Ledger.streamFetchByKey\", template, 'v1/stream/fetch', request, reconnectRequest, null, change);\n    };\n    /**\n     * @internal\n     *\n     * Returns the same API as [[streamSubmit]] but does not, in fact, establish\n     * any socket connection. Instead, this is a stream that always has the given\n     * value as its accumulated state.\n     */\n    Ledger.prototype.constantStream = function (value) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function on(type, listener) {\n            if (type === 'live') {\n                listener(value);\n            }\n            if (type === 'change') {\n                listener(value, []);\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars, @typescript-eslint/no-empty-function\n        function off(_t, _l) { }\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return { on: on, off: off, close: function () { } };\n    };\n    /**\n     * Retrieve a consolidated stream of events for a list of keys and a single\n     * template.\n     *\n     * The accumulated state is an array of the same length as the given list of\n     * keys, with positional correspondence. Each element in the array represents\n     * the current contract for the given key, or is explicitly null if there is\n     * currently no active contract matching that key.\n     *\n     * Note: the given `key` objects will be compared for (deep) equality with\n     * the values returned by the API. As such, they have to be given in the\n     * \"output\" format of the API, including the values of\n     * `encodeDecimalAsString` and `encodeInt64AsString`. See [the JSON API docs\n     * for details](https://docs.daml.com/json-api/lf-value-specification.html).\n     *\n     * @typeparam T The contract template type.\n     * @typeparam K The contract key type.\n     * @typeparam I The contract id type.\n     */\n    Ledger.prototype.streamFetchByKeys = function (template, keys) {\n        // We support zero-length key so clients can more easily manage a dynamic\n        // list, without having to special-case 0-length on their side.\n        if (keys.length == 0) {\n            return this.constantStream([]);\n        }\n        var lastContractIds = Array(keys.length).fill(null);\n        var keysCopy = lodash_1.default.cloneDeep(keys);\n        var initState = Array(keys.length).fill(null);\n        var request = keys.map(function (k) { return ({ templateId: template.templateId, key: template.keyEncode(k) }); });\n        var reconnectRequest = function () { return request.map(function (r, idx) {\n            var lastId = lastContractIds[idx];\n            return __assign(__assign({}, r), { 'contractIdAtOffset': lastId && types_1.ContractId(template).encode(lastId) });\n        }); };\n        var change = function (state, events) {\n            var newState = Array.from(state);\n            var _loop_1 = function (event_5) {\n                if ('created' in event_5) {\n                    var k_1 = event_5.created.key;\n                    keysCopy.forEach(function (requestKey, idx) {\n                        if (lodash_1.default.isEqual(requestKey, k_1)) {\n                            newState[idx] = event_5.created;\n                        }\n                    });\n                }\n                else { // i.e. 'archived' in event\n                    var id_1 = event_5.archived.contractId;\n                    newState.forEach(function (contract, idx) {\n                        if (contract && contract.contractId === id_1) {\n                            newState[idx] = null;\n                        }\n                    });\n                }\n            };\n            for (var _i = 0, events_7 = events; _i < events_7.length; _i++) {\n                var event_5 = events_7[_i];\n                _loop_1(event_5);\n            }\n            newState.forEach(function (c, idx) {\n                lastContractIds[idx] = c ? c.contractId : null;\n            });\n            return newState;\n        };\n        return this.streamSubmit(\"streamFetchByKeys\", template, 'v1/stream/fetch', request, reconnectRequest, initState, change);\n    };\n    /**\n     * Fetch parties by identifier.\n     *\n     * @param parties An array of Party identifiers.\n     *\n     * @returns An array of the same length, where each element corresponds to\n     * the same-index element of the given parties, ans is either a PartyInfo\n     * object if the party exists or null if it does not.\n     *\n     */\n    Ledger.prototype.getParties = function (parties) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json, resp, mapping, _i, resp_1, p, ret, idx;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (parties.length === 0) {\n                            return [2 /*return*/, []];\n                        }\n                        return [4 /*yield*/, this.submit('v1/parties', parties)];\n                    case 1:\n                        json = _a.sent();\n                        resp = decode(jtv.array(partyInfoDecoder), json);\n                        mapping = {};\n                        for (_i = 0, resp_1 = resp; _i < resp_1.length; _i++) {\n                            p = resp_1[_i];\n                            mapping[p.identifier] = p;\n                        }\n                        ret = Array(parties.length).fill(null);\n                        for (idx = 0; idx < parties.length; idx++) {\n                            ret[idx] = mapping[parties[idx]] || null;\n                        }\n                        return [2 /*return*/, ret];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch all parties on the ledger.\n     *\n     * @returns All parties on the ledger, in no particular order.\n     *\n     */\n    Ledger.prototype.listKnownParties = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit('v1/parties', undefined, 'get')];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(partyInfoDecoder), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Allocate a new party.\n     *\n     * @param partyOpt Parameters for party allocation.\n     *\n     * @returns PartyInfo for the newly created party.\n     *\n     */\n    Ledger.prototype.allocateParty = function (partyOpt) {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit('v1/parties/allocate', partyOpt)];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(partyInfoDecoder, json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a list of all package IDs from the ledger.\n     *\n     * @returns List of package IDs.\n     *\n     */\n    Ledger.prototype.listPackages = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var json;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.submit('v1/packages', undefined, 'get')];\n                    case 1:\n                        json = _a.sent();\n                        return [2 /*return*/, decode(jtv.array(jtv.string()), json)];\n                }\n            });\n        });\n    };\n    /**\n     * Fetch a binary package.\n     *\n     * @returns The content of the package as a raw ArrayBuffer.\n     *\n     */\n    Ledger.prototype.getPackage = function (id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cross_fetch_1.default(this.httpBaseUrl + 'v1/packages/' + id, {\n                            headers: this.auth(),\n                            method: 'get',\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, httpResponse.arrayBuffer()];\n                    case 3: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Upload a binary archive. Note that this requires admin privileges.\n     *\n     * @returns No return value on success; throws on error.\n     *\n     */\n    Ledger.prototype.uploadDarFile = function (abuf) {\n        return __awaiter(this, void 0, void 0, function () {\n            var httpResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cross_fetch_1.default(this.httpBaseUrl + 'v1/packages', {\n                            body: abuf,\n                            headers: __assign(__assign({}, this.auth()), { 'Content-type': 'application/octet-stream' }),\n                            method: 'post',\n                        })];\n                    case 1:\n                        httpResponse = _a.sent();\n                        return [4 /*yield*/, this.throwOnError(httpResponse)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return Ledger;\n}());\nexports.default = Ledger;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}